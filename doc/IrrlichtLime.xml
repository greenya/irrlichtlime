<?xml version="1.0"?>
<doc>
	<assembly>
		<name>IrrlichtLime</name>
	</assembly>
	<members>
		<member name="T:IrrlichtLime.DeviceType">
			<summary>An enum for the different device types supported by the Irrlicht Engine.</summary>
		</member>
		<member name="F:IrrlichtLime.DeviceType.Best">
			<summary>This selection allows Irrlicht to choose the best device from the ones available.

If this selection is chosen then Irrlicht will try to use the IrrlichtDevice native to your operating system. If this is unavailable then the X11, SDL and then console device will be tried. This ensures that Irrlicht will run even if your platform is unsupported, although it may not be able to render anything.</summary>
		</member>
		<member name="F:IrrlichtLime.DeviceType.Console">
			<summary>A simple text only device supported by all platforms.

This device allows applications to run from the command line without opening a window. It can render the output of the software drivers to the console as ASCII. It only supports mouse and keyboard in Windows operating systems.</summary>
		</member>
		<member name="F:IrrlichtLime.DeviceType.FrameBuffer">
			<summary>A device for raw framebuffer access.

Best used with embedded devices and mobile systems. Does not need X11 or other graphical subsystems. May support hw-acceleration via OpenGL-ES for FBDirect.</summary>
		</member>
		<member name="F:IrrlichtLime.DeviceType.OSX">
			<summary>A device native to Mac OSX.

This device uses Apple's Cocoa API and works in Mac OSX 10.2 and above.</summary>
		</member>
		<member name="F:IrrlichtLime.DeviceType.SDL">
			<summary>A device which uses Simple DirectMedia Layer.

The SDL device works under all platforms supported by SDL.</summary>
		</member>
		<member name="F:IrrlichtLime.DeviceType.Win32">
			<summary>A device native to Microsoft Windows.

This device uses the Win32 API and works in all versions of Windows.</summary>
		</member>
		<member name="F:IrrlichtLime.DeviceType.WinCE">
			<summary>A device native to Windows CE devices.

This device works on Windows Mobile, Pocket PC and Microsoft SmartPhone devices.</summary>
		</member>
		<member name="F:IrrlichtLime.DeviceType.X11">
			<summary>A device native to Unix style operating systems.

This device uses the X11 windowing system and works in Linux, Solaris, FreeBSD, OSX and other operating systems which support X11.</summary>
		</member>
		<member name="T:IrrlichtLime.Event">
			<summary>Holds information about an event.</summary>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(System.Char,IrrlichtLime.KeyCode,System.Boolean)">
			<summary>Constructs keyboard event.</summary>
			<param name="ch">Character corresponding to the key (0, if not a character).</param>
			<param name="key">Key which has been pressed or released.</param>
			<param name="pressedDown">If not true, then the key was left up.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(System.Char,IrrlichtLime.KeyCode,System.Boolean,System.Boolean,System.Boolean)">
			<summary>Constructs keyboard event.</summary>
			<param name="ch">Character corresponding to the key (0, if not a character).</param>
			<param name="key">Key which has been pressed or released.</param>
			<param name="pressedDown">If not true, then the key was left up.</param>
			<param name="shift">True if shift was also pressed.</param>
			<param name="control">True if ctrl was also pressed.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(System.Byte,System.Int16[],System.UInt16)">
			<summary>Constructs joystick event.</summary>
			<param name="joystick">The ID of the joystick which generated this event.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(System.Byte,System.Int16[],System.UInt16,System.UInt32)">
			<summary>Constructs joystick event.</summary>
			<param name="joystick">The ID of the joystick which generated this event.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(System.String)">
			<summary>Constructs log event.</summary>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(System.String,IrrlichtLime.LogLevel)">
			<summary>Constructs log event.</summary>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.GUI.GUIEventType,IrrlichtLime.GUI.GUIElement)">
			<summary>Constructs GUI event.</summary>
			<param name="type">Type of GUI Event.</param>
			<param name="caller">Who called the event.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.GUI.GUIEventType,IrrlichtLime.GUI.GUIElement,IrrlichtLime.GUI.GUIElement)">
			<summary>Constructs GUI event.</summary>
			<param name="type">Type of GUI Event.</param>
			<param name="caller">Who called the event.</param>
			<param name="element">If the event has something to do with another element, it will be held here.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.MouseEventType,System.Int32,System.Int32)">
			<summary>Constructs mouse event.</summary>
			<param name="type">Type of mouse event.</param>
			<param name="x">X position of mouse cursor.</param>
			<param name="y">Y position of mouse cursor.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.MouseEventType,System.Int32,System.Int32,System.Single)">
			<summary>Constructs mouse event.</summary>
			<param name="type">Type of mouse event.</param>
			<param name="x">X position of mouse cursor.</param>
			<param name="y">Y position of mouse cursor.</param>
			<param name="wheel">Mouse wheel delta, usually 1.0 or -1.0.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.MouseEventType,System.Int32,System.Int32,System.Single,System.UInt32)">
			<summary>Constructs mouse event.</summary>
			<param name="type">Type of mouse event.</param>
			<param name="x">X position of mouse cursor.</param>
			<param name="y">Y position of mouse cursor.</param>
			<param name="wheel">Mouse wheel delta, usually 1.0 or -1.0.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(IrrlichtLime.MouseEventType,System.Int32,System.Int32,System.Single,System.UInt32,System.Boolean,System.Boolean)">
			<summary>Constructs mouse event.</summary>
			<param name="type">Type of mouse event.</param>
			<param name="x">X position of mouse cursor.</param>
			<param name="y">Y position of mouse cursor.</param>
			<param name="wheel">Mouse wheel delta, usually 1.0 or -1.0.</param>
			<param name="shift">True if shift was also pressed.</param>
			<param name="control">True if ctrl was also pressed.</param>
		</member>
		<member name="M:IrrlichtLime.Event.#ctor(System.Int32,System.Int32)">
			<summary>Constructs user event.</summary>
			<param name="userData1">Some user specified data as int.</param>
			<param name="userData2">Another user specified data as int.</param>
		</member>
		<member name="P:IrrlichtLime.Event.GUI">
			<summary>GUI event.
Can be used only when Type == EventType.GUI.</summary>
		</member>
		<member name="T:IrrlichtLime.Event.GUIEvent">
			<summary>Any kind of GUI event.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.GUIEvent.Caller">
			<summary>Who called the event.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.GUIEvent.Element">
			<summary>If the event has something to do with another element, it will be held here.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.GUIEvent.Type">
			<summary>Type of GUI Event.</summary>
		</member>
		<member name="P:IrrlichtLime.Event.Joystick">
			<summary>Joystick event.
Can be used only when Type == EventType.Joystick.</summary>
		</member>
		<member name="T:IrrlichtLime.Event.JoystickEvent">
			<summary>Any kind of joystick event.</summary>
		</member>
		<member name="M:IrrlichtLime.Event.JoystickEvent.IsButtonPressed(System.Int32)">
			<summary>A helper function to check if a button is pressed.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.JoystickEvent.Joystick">
			<summary>The ID of the joystick which generated this event.</summary>
		</member>
		<member name="P:IrrlichtLime.Event.Key">
			<summary>Keyboard event.
Can be used only when Type == EventType.Key.</summary>
		</member>
		<member name="T:IrrlichtLime.Event.KeyEvent">
			<summary>Any kind of keyboard event.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.KeyEvent.Char">
			<summary>Character corresponding to the key (0, if not a character).</summary>
		</member>
		<member name="F:IrrlichtLime.Event.KeyEvent.Control">
			<summary>True if ctrl was also pressed.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.KeyEvent.Key">
			<summary>Key which has been pressed or released.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.KeyEvent.PressedDown">
			<summary>If not true, then the key was left up.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.KeyEvent.Shift">
			<summary>True if shift was also pressed.</summary>
		</member>
		<member name="P:IrrlichtLime.Event.Log">
			<summary>Log event.
Can be used only when Type == EventType.Log.</summary>
		</member>
		<member name="T:IrrlichtLime.Event.LogEvent">
			<summary>Any kind of log event.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.LogEvent.Level">
			<summary>Log level in which the text has been logged.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.LogEvent.Text">
			<summary>Text which has been logged.</summary>
		</member>
		<member name="P:IrrlichtLime.Event.Mouse">
			<summary>Mouse event.
Can be used only when Type == EventType.Mouse.</summary>
		</member>
		<member name="T:IrrlichtLime.Event.MouseEvent">
			<summary>Any kind of mouse event.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.MouseEvent.ButtonStates">
			<summary>State of mouse buttons.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.MouseEvent.Control">
			<summary>True if ctrl was also pressed.</summary>
		</member>
		<member name="M:IrrlichtLime.Event.MouseEvent.IsLeftPressed">
			<summary>Is the left button pressed down?</summary>
		</member>
		<member name="M:IrrlichtLime.Event.MouseEvent.IsMiddlePressed">
			<summary>Is the middle button pressed down?</summary>
		</member>
		<member name="M:IrrlichtLime.Event.MouseEvent.IsRightPressed">
			<summary>Is the right button pressed down?</summary>
		</member>
		<member name="F:IrrlichtLime.Event.MouseEvent.Shift">
			<summary>True if shift was also pressed.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.MouseEvent.Type">
			<summary>Type of mouse event.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.MouseEvent.Wheel">
			<summary>Mouse wheel delta, usually 1.0 or -1.0.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.MouseEvent.X">
			<summary>X position of mouse cursor.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.MouseEvent.Y">
			<summary>Y position of mouse cursor.</summary>
		</member>
		<member name="P:IrrlichtLime.Event.Type">
			<summary>Type of the event.</summary>
		</member>
		<member name="P:IrrlichtLime.Event.User">
			<summary>User event.
Can be used only when Type == EventType.User.</summary>
		</member>
		<member name="T:IrrlichtLime.Event.UserEvent">
			<summary>Any kind of user event.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.UserEvent.UserData1">
			<summary>Some user specified data as int.</summary>
		</member>
		<member name="F:IrrlichtLime.Event.UserEvent.UserData2">
			<summary>Another user specified data as int.</summary>
		</member>
		<member name="T:IrrlichtLime.EventType">
			<summary>Enumeration for all event types there are.</summary>
		</member>
		<member name="F:IrrlichtLime.EventType.GUI">
			<summary>An event of the graphical user interface.

GUI events are created by the GUI environment or the GUI elements in response to mouse or keyboard events. When a GUI element receives an event it will either process it and return true, or pass the event to its parent. If an event is not absorbed before it reaches the root element then it will then be passed to the user receiver.</summary>
		</member>
		<member name="F:IrrlichtLime.EventType.Joystick">
			<summary>A joystick (joypad, gamepad) input event.

Joystick events are created by polling all connected joysticks once per device Run() and then passing the events to IrrlichtDevice.PostEvent(). They take the same path as mouse events.

Windows, SDL: Implemented.
Linux: Implemented, with POV hat issues.
MacOS / Other: Not yet implemented.</summary>
		</member>
		<member name="F:IrrlichtLime.EventType.Key">
			<summary>A key input event.

Like mouse events, keyboard events are created by the device and passed to IrrlichtDevice.PostEvent(). They take the same path as mouse events.</summary>
		</member>
		<member name="F:IrrlichtLime.EventType.Log">
			<summary>A log event.

Log events are only passed to the user receiver if there is one. If they are absorbed by the user receiver then no text will be sent to the console.</summary>
		</member>
		<member name="F:IrrlichtLime.EventType.Mouse">
			<summary>A mouse input event.

Mouse events are created by the device and passed to IrrlichtDevice.PostEvent() in response to mouse input received from the operating system. Mouse events are first passed to the user receiver, then to the GUI environment and its elements, then finally the input receiving scene manager where it is passed to the active camera.</summary>
		</member>
		<member name="F:IrrlichtLime.EventType.User">
			<summary>A user event with user data.

This is not used by Irrlicht and can be used to send user specific data though the system.</summary>
		</member>
		<member name="T:IrrlichtLime.IrrlichtCreationParameters">
			<summary>Advanced Irrlicht Device creation parameters. Used as argument for IrrlichtDevice.CreateDevice() method.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.AlphaChannel">
			<summary>Whether the main framebuffer uses an alpha channel.

In some situations it might be desireable to get a color buffer with an alpha channel, e.g. when rendering into a transparent window or overlay. If this flag is set the device tries to create a framebuffer with alpha channel. If this flag is set, only color buffers with alpha channel are considered. Otherwise, it depends on the actual hardware if the colorbuffer has an alpha channel or not.

Default value: false.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.AntiAliasing">
			<summary>Specifies if the device should use fullscreen anti aliasing.

Makes sharp/pixelated edges softer, but requires more performance. Also, 2D elements might look blurred with this switched on. The resulting rendering quality also depends on the hardware and driver you are using, your program might look different on different hardware with this. So if you are writing a game/application with AntiAlias switched on, it would be a good idea to make it possible to switch this option off again by the user. The value is the maximal antialiasing factor requested for the device. The cretion method will automatically try smaller values if no window can be created with the given value. Value one is usually the same as 0 (disabled), but might be a special value on some platforms. On D3D devices it maps to NONMASKABLE.

Default value: 0 - disabled.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.BitsPerPixel">
			<summary>Minimum Bits per pixel of the color buffer in fullscreen mode. Ignored if windowed mode.

Default value: 16.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.DeviceType">
			<summary>Type of the device.

This setting decides the windowing system used by the device, most device types are native to a specific operating system and so may not be available. DeviceType.Win32 is only available on Windows desktops, DeviceType.WinCE is only available on Windows mobile devices, DeviceType.COCOA is only available on Mac OSX, DeviceType.X11 is available on Linux, Solaris, BSD and other operating systems which use X11, DeviceType.SDL is available on most systems if compiled in, DeviceType.Console is usually available but can only render to text, DeviceType.Best will select the best available device for your operating system. 
Default value: DeviceType.Best.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.DoubleBuffer">
			<summary>Whether the main framebuffer uses doublebuffering.

This should be usually enabled, in order to avoid render artifacts on the visible framebuffer. However, it might be useful to use only one buffer on very small devices. If no doublebuffering is available, the drivers will fall back to single buffers.

Default value: true.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.DriverType">
			<summary>Type of video driver used to render graphics.

Default value: DriverType.Software.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.Fullscreen">
			<summary>Should be set to true if the device should run in fullscreen.

Otherwise the device runs in windowed mode.

Default: false.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.HighPrecisionFPU">
			<summary>Specifies if the device should use high precision FPU setting.

This is only relevant for DirectX devices, which switch to low FPU precision by default for performance reasons. However, this may lead to problems with the other computations of the application. In this case setting this flag to true should help on the expense of performance loss, though.

Default value: false.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.IgnoreInput">
			<summary>Specifies if the device should ignore input events.

This is only relevant when using external I/O handlers. External windows need to take care of this themselves. Currently only supported by X11.

Default value: false.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtCreationParameters.#ctor">
			<summary>Constructs a IrrlichtCreationParameters instance with default values.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.LoggingLevel">
			<summary>Specifies the logging level used in the logging interface.

You can access the ILogger interface later on from the IrrlichtDevice with getLogger() and set another level. But if you need more or less logging information already from device creation, then you have to change it here.

Default value: LogLevel.Information.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.StencilBuffer">
			<summary>Specifies if the stencil buffer should be enabled.

Set this to true, if you want the engine be able to draw stencil buffer shadows. Note that not all drivers are able to use the stencil buffer, hence it can be ignored during device creation. Without the stencil buffer no shadows will be drawn.

Default value: false.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.StereoBuffer">
			<summary>Specifies if the device should use stereo buffers.

Some high-end gfx cards support two framebuffers for direct support of stereoscopic output devices. If this flag is set the device tries to create a stereo context. Currently only supported by OpenGL.

Default value: false.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.VSync">
			<summary>Specifies vertical syncronisation.

If set to true, the driver will wait for the vertical retrace period, otherwise not. May be silently ignored.

Default value: false.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.WindowID">
			<summary>Window ID.

If this is set to a value other than 0, the Irrlicht Engine will be created in an already existing window. For windows, set this to the HWND of the window you want. The windowSize and FullScreen options will be ignored when using the WindowID parameter. To make Irrlicht run inside the custom window, you still will have to draw Irrlicht on your own.

Default value: 0 - use own window.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.WindowSize">
			<summary>Size of the window or the video mode in fullscreen mode.

Default value: 800 x 600.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtCreationParameters.ZBufferBits">
			<summary>Minimum bits per pixel of the depth buffer.

Default value: 16.</summary>
		</member>
		<member name="T:IrrlichtLime.IrrlichtDevice">
			<summary>The Irrlicht device. You can create it with CreateDevice().

This is the most important class of the Irrlicht Engine. You can access everything in the engine if you have a pointer to an instance of this class. There should be only one instance of this class at any time.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.ClearSystemMessages">
			<summary>Remove messages pending in the system message loop.

This function is usually used after messages have been buffered for a longer time, for example when loading a large scene. Clearing the message loop prevents that mouse- or buttonclicks which users have pressed in the meantime will now trigger unexpected actions in the gui.

So far the following messages are cleared:
Win32: All keyboard and mouse messages;
Linux: All keyboard and mouse messages;
All other devices are not yet supported here.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.Close">
			<summary>Notifies the device that it should close itself.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.ColorFormat">
			<summary>Current color format of the window.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.CreateDevice">
			<summary>Creates an Irrlicht device. The Irrlicht device is the root object for using the engine.</summary>
			<returns>Created IrrlichtDevice or null if the device could not be created.</returns>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.CreateDevice(IrrlichtLime.Video.DriverType)">
			<summary>Creates an Irrlicht device. The Irrlicht device is the root object for using the engine.</summary>
			<param name="driverType">Type of the device.</param>
			<returns>Created IrrlichtDevice or null if the device could not be created.</returns>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.CreateDevice(IrrlichtLime.Video.DriverType,IrrlichtLime.Core.Dimension2Di)">
			<summary>Creates an Irrlicht device. The Irrlicht device is the root object for using the engine.</summary>
			<param name="driverType">Type of the device.</param>
			<param name="windowSize">Size of the window or the video mode in fullscreen mode.</param>
			<returns>Created IrrlichtDevice or null if the device could not be created.</returns>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.CreateDevice(IrrlichtLime.Video.DriverType,IrrlichtLime.Core.Dimension2Di,System.Int32)">
			<summary>Creates an Irrlicht device. The Irrlicht device is the root object for using the engine.</summary>
			<param name="driverType">Type of the device.</param>
			<param name="windowSize">Size of the window or the video mode in fullscreen mode.</param>
			<param name="bits">Bits per pixel in fullscreen mode. Ignored if windowed mode.</param>
			<returns>Created IrrlichtDevice or null if the device could not be created.</returns>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.CreateDevice(IrrlichtLime.Video.DriverType,IrrlichtLime.Core.Dimension2Di,System.Int32,System.Boolean)">
			<summary>Creates an Irrlicht device. The Irrlicht device is the root object for using the engine.</summary>
			<param name="driverType">Type of the device.</param>
			<param name="windowSize">Size of the window or the video mode in fullscreen mode.</param>
			<param name="bits">Bits per pixel in fullscreen mode. Ignored if windowed mode.</param>
			<param name="fullscreen">Should be set to true if the device should run in fullscreen. Otherwise the device runs in windowed mode.</param>
			<returns>Created IrrlichtDevice or null if the device could not be created.</returns>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.CreateDevice(IrrlichtLime.Video.DriverType,IrrlichtLime.Core.Dimension2Di,System.Int32,System.Boolean,System.Boolean)">
			<summary>Creates an Irrlicht device. The Irrlicht device is the root object for using the engine.</summary>
			<param name="driverType">Type of the device.</param>
			<param name="windowSize">Size of the window or the video mode in fullscreen mode.</param>
			<param name="bits">Bits per pixel in fullscreen mode. Ignored if windowed mode.</param>
			<param name="fullscreen">Should be set to true if the device should run in fullscreen. Otherwise the device runs in windowed mode.</param>
			<param name="stencilbuffer">Specifies if the stencil buffer should be enabled. Set this to true, if you want the engine be able to draw stencil buffer shadows. Note that not all devices are able to use the stencil buffer. If they don't - no shadows will be drawn.</param>
			<returns>Created IrrlichtDevice or null if the device could not be created.</returns>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.CreateDevice(IrrlichtLime.Video.DriverType,IrrlichtLime.Core.Dimension2Di,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
			<summary>Creates an Irrlicht device. The Irrlicht device is the root object for using the engine.</summary>
			<param name="driverType">Type of the device.</param>
			<param name="windowSize">Size of the window or the video mode in fullscreen mode.</param>
			<param name="bits">Bits per pixel in fullscreen mode. Ignored if windowed mode.</param>
			<param name="fullscreen">Should be set to true if the device should run in fullscreen. Otherwise the device runs in windowed mode.</param>
			<param name="stencilbuffer">Specifies if the stencil buffer should be enabled. Set this to true, if you want the engine be able to draw stencil buffer shadows. Note that not all devices are able to use the stencil buffer. If they don't - no shadows will be drawn.</param>
			<param name="vsync">Specifies vertical syncronisation: If set to true, the driver will wait for the vertical retrace period, otherwise not.</param>
			<returns>Created IrrlichtDevice or null if the device could not be created.</returns>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.CreateDevice(IrrlichtLime.IrrlichtCreationParameters)">
			<summary>Creates an Irrlicht device with the option to specify advanced parameters. The Irrlicht device is the root object for using the engine.</summary>
			<param name="parameters">Advanced parameters for the creation of the device. See IrrlichtCreationParameters for details.</param>
			<returns>Created IrrlichtDevice or null if the device could not be created.</returns>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.CursorControl">
			<summary>Provides access to the mouse cursor.</summary>
		</member>
		<member name="T:IrrlichtLime.IrrlichtDevice.EventHandler">
			<summary>Called if an event happened.

Please take care that you should only return 'true' when you want to _prevent_ Irrlicht from processing the event any further. So 'true' does mean that an event is completely done. Therefore your return value for all unprocessed events should be 'false'.</summary>
			<param name="evnt">Event details.</param>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.FileSystem">
			<summary>Provides access to the virtual file system.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.Fullscreen">
			<summary>Checks if the Irrlicht window is running in fullscreen mode.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.GetGammaRamp(System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
			<summary>Get the current gamma value for the display.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.GUIEnvironment">
			<summary>Provides access to the 2d user interface environment.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.IsDriverSupported(IrrlichtLime.Video.DriverType)">
			<summary>Check if a driver type is supported by the engine.

Even if true is returned the driver may not be available for a configuration requested when creating the device.</summary>
			<param name="driver">Driver type to check.</param>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.Logger">
			<summary>Provides access to the message logger.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.MaximizeWindow">
			<summary>Maximizes the window if possible.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.MinimizeWindow">
			<summary>Minimizes the window if possible.</summary>
		</member>
		<member name="E:IrrlichtLime.IrrlichtDevice.OnEvent">
			<summary>Called if an event happened.

Raises for each event from the engine.

If you handle this event, you should return true if you have handled the event, and false -- if not (in this case Irrlicht Engine will process it).</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.OSOperator">
			<summary>Provides access to the operation system functionality.

The OS operator provides methods for getting system specific informations and doing system specific operations, such as exchanging data with the clipboard or reading the operation system version.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.PostEvent(IrrlichtLime.Event)">
			<summary>Sends a user created event to the engine.

Is is usually not necessary to use this. However, if you are using an own input library for example for doing joystick input, you can use this to post key or mouse input events to the engine. Internally, this method only delegates the events further to the scene manager and the GUI environment.</summary>
			<param name="e">Event to post.</param>
			<returns>True if event has been handled.</returns>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.RestoreWindow">
			<summary>Restore the window to normal size if possible.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.Run">
			<summary>Runs the device.

Also increments the virtual timer by calling Timer.Tick(). You can prevent this by calling Timer.Stop() before and Timer.Start() after calling IrrlichtDevice.Run(). Returns false if device wants to be deleted.

Note if you are running Irrlicht inside an external, custom created window calling device.Run() will cause Irrlicht to dispatch windows messages internally. If you are running Irrlicht in your own custom window, you can also simply use your own message loop using GetMessage, DispatchMessage and whatever and simply don't use this method. But note that Irrlicht will not be able to fetch user input then. See IrrlichtCreationParameters.WindowID for more information.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.SceneManager">
			<summary>Provides access to the scene manager.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.SetGammaRamp(System.Single,System.Single,System.Single,System.Single,System.Single)">
			<summary>Set the current gamma value for the display.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.SetInputReceivingSceneManager(IrrlichtLime.Scene.SceneManager)">
			<summary>Sets the input receiving scene manager. If set to null, the main scene manager (returned by SceneManager property) will receive the input.</summary>
			<param name="sceneManager">New scene manager to be used.</param>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.SetWindowCaption(System.String)">
			<summary>Sets the caption of the window.</summary>
			<param name="text">New text of the window caption.</param>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.SetWindowResizable(System.Boolean)">
			<summary>Sets if the window should be resizable in windowed mode. This method only works in windowed mode.

Default value: false.</summary>
			<param name="resize">Flag whether the window should be resizable.</param>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.Sleep(System.Int32)">
			<summary>Pause execution and let other processes to run for a specified amount of time. It may not wait the full given time, as sleep may be interrupted.</summary>
			<param name="timeMs">Time to sleep for in milisecs.</param>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.Sleep(System.Int32,System.Boolean)">
			<summary>Pause execution and let other processes to run for a specified amount of time. It may not wait the full given time, as sleep may be interrupted.</summary>
			<param name="timeMs">Time to sleep for in milisecs.</param>
			<param name="pauseTimer">If true, pauses the device timer while sleeping.</param>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.Timer">
			<summary>Provides access to the engine's timer. The system time can be retrieved by it as well as the virtual time, which also can be manipulated.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.Type">
			<summary>Get the type of the device. This allows the user to check which windowing system is currently being used.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.Version">
			<summary>Version of the Irrlicht Engine. The returned string will look like: "1.2.3" or "1.2".</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.VideoDriver">
			<summary>Provides access to the video driver for drawing 3d and 2d geometry.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.VideoModeList">
			<summary>List with all video modes available.

There is no need to start up an Irrlicht Device with Direct3D, OpenGL or Software driver: you can use Null device for this property to use.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.WindowActive">
			<summary>Checks if the Irrlicht window is active.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.WindowFocused">
			<summary>Checks if the Irrlicht window has focus.</summary>
		</member>
		<member name="P:IrrlichtLime.IrrlichtDevice.WindowMinimized">
			<summary>Checks if the Irrlicht window is minimized.</summary>
		</member>
		<member name="M:IrrlichtLime.IrrlichtDevice.Yield">
			<summary>Cause the device to temporarily pause execution and let other processes run. This should bring down processor usage without major performance loss for Irrlicht.</summary>
		</member>
		<member name="T:IrrlichtLime.KeyAction">
			<summary>Key actions. Used for example in the FPS Camera.</summary>
		</member>
		<member name="F:IrrlichtLime.KeyAction.Crouch">
			<summary>Crouch action.</summary>
		</member>
		<member name="F:IrrlichtLime.KeyAction.Jump">
			<summary>Jump action.</summary>
		</member>
		<member name="F:IrrlichtLime.KeyAction.MoveBackward">
			<summary>Move backward action.</summary>
		</member>
		<member name="F:IrrlichtLime.KeyAction.MoveForward">
			<summary>Move forward action.</summary>
		</member>
		<member name="F:IrrlichtLime.KeyAction.StrafeLeft">
			<summary>Strafe left action.</summary>
		</member>
		<member name="F:IrrlichtLime.KeyAction.StrafeRight">
			<summary>Strafe right action.</summary>
		</member>
		<member name="T:IrrlichtLime.KeyCode">
			<summary>Key codes.</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Add">
			<summary>Add key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Alt">
			<summary>ALT key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Apps">
			<summary>Applications key (Natural keyboard)</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Attn">
			<summary>Attn key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Backspace">
			<summary>BACKSPACE key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.CapsLock">
			<summary>CAPS LOCK key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Clear">
			<summary>CLEAR key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Comma">
			<summary>Comma Key (,)</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.CrSel">
			<summary>CrSel key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Ctrl">
			<summary>CTRL key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Decimal">
			<summary>Decimal key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Delete">
			<summary>DEL key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Devide">
			<summary>Divide key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Down">
			<summary>DOWN ARROW key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.End">
			<summary>END key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.ErEOF">
			<summary>Erase EOF key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Esc">
			<summary>ESC key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Execute">
			<summary>EXECUTE key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.ExSel">
			<summary>ExSel key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F1">
			<summary>F1 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F10">
			<summary>F10 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F11">
			<summary>F11 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F12">
			<summary>F12 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F13">
			<summary>F13 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F14">
			<summary>F14 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F15">
			<summary>F15 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F16">
			<summary>F16 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F17">
			<summary>F17 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F18">
			<summary>F18 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F19">
			<summary>F19 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F2">
			<summary>F2 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F20">
			<summary>F20 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F21">
			<summary>F21 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F22">
			<summary>F22 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F23">
			<summary>F23 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F24">
			<summary>F24 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F3">
			<summary>F3 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F4">
			<summary>F4 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F5">
			<summary>F5 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F6">
			<summary>F6 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F7">
			<summary>F7 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F8">
			<summary>F8 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.F9">
			<summary>F9 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Help">
			<summary>HELP key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Home">
			<summary>HOME key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_Accept">
			<summary>IME accept</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_Convert">
			<summary>IME convert</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_Final">
			<summary>IME final mode</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_Hangul">
			<summary>IME Hangul mode</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_Hanja">
			<summary>IME Hanja mode</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_Junja">
			<summary>IME Junja mode</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_Kana">
			<summary>IME Kana mode</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_Kanji">
			<summary>IME Kanji mode</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_ModeChange">
			<summary>IME mode change request</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.IME_NonConvert">
			<summary>IME nonconvert</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Insert">
			<summary>INS key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key0">
			<summary>0 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key1">
			<summary>1 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key2">
			<summary>2 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key3">
			<summary>3 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key4">
			<summary>4 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key5">
			<summary>5 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key6">
			<summary>6 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key7">
			<summary>7 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key8">
			<summary>8 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Key9">
			<summary>9 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyA">
			<summary>A key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyB">
			<summary>B key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyC">
			<summary>C key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyD">
			<summary>D key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyE">
			<summary>E key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyF">
			<summary>F key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyG">
			<summary>G key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyH">
			<summary>H key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyI">
			<summary>I key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyJ">
			<summary>J key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyK">
			<summary>K key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyL">
			<summary>L key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyM">
			<summary>M key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyN">
			<summary>N key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyO">
			<summary>O key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyP">
			<summary>P key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyQ">
			<summary>Q key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyR">
			<summary>R key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyS">
			<summary>S key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyT">
			<summary>T key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyU">
			<summary>U key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyV">
			<summary>V key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyW">
			<summary>W key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyX">
			<summary>X key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyY">
			<summary>Y key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.KeyZ">
			<summary>Z key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.LControl">
			<summary>Left CONTROL key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Left">
			<summary>LEFT ARROW key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.LMenu">
			<summary>Left MENU key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.LShift">
			<summary>Left SHIFT key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.LWin">
			<summary>Left Windows key (Microsoft® Natural® keyboard)</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Minus">
			<summary>Minus Key (-)</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.MouseLButton">
			<summary>Left mouse button</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.MouseMButton">
			<summary>Middle mouse button (three-button mouse)</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.MouseRButton">
			<summary>Right mouse button</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.MouseXButton1">
			<summary>Windows 2000/XP: X1 mouse button</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.MouseXButton2">
			<summary>Windows 2000/XP: X2 mouse button</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Multiply">
			<summary>Multiply key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num0">
			<summary>Numeric keypad 0 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num1">
			<summary>Numeric keypad 1 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num2">
			<summary>Numeric keypad 2 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num3">
			<summary>Numeric keypad 3 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num4">
			<summary>Numeric keypad 4 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num5">
			<summary>Numeric keypad 5 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num6">
			<summary>Numeric keypad 6 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num7">
			<summary>Numeric keypad 7 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num8">
			<summary>Numeric keypad 8 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Num9">
			<summary>Numeric keypad 9 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.NumLock">
			<summary>NUM LOCK key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.OEM_Clear">
			<summary>Clear key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.PA1">
			<summary>PA1 key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.PageDown">
			<summary>PAGE DOWN key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.PageUp">
			<summary>PAGE UP key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Pause">
			<summary>PAUSE key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Period">
			<summary>Period Key (.)</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Play">
			<summary>Play key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Plus">
			<summary>Plus Key (+)</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Print">
			<summary>PRINT key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.PrintScreen">
			<summary>PRINT SCREEN key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.RControl">
			<summary>Right CONTROL key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Return">
			<summary>ENTER key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Right">
			<summary>RIGHT ARROW key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.RMenu">
			<summary>Right MENU key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.RShift">
			<summary>Right SHIFT key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.RWin">
			<summary>Right Windows key (Natural keyboard)</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.ScrollLock">
			<summary>SCROLL LOCK key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Select">
			<summary>SELECT key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Separator">
			<summary>Separator key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Shift">
			<summary>SHIFT key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Sleep">
			<summary>Computer Sleep key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Space">
			<summary>SPACEBAR key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Subtract">
			<summary>Subtract key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Tab">
			<summary>TAB key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Up">
			<summary>UP ARROW key</summary>
		</member>
		<member name="F:IrrlichtLime.KeyCode.Zoom">
			<summary>Zoom key</summary>
		</member>
		<member name="T:IrrlichtLime.KeyMap">
			<summary>Key map. Used when creating FPS camera to specify key mapping.</summary>
		</member>
		<member name="M:IrrlichtLime.KeyMap.Add(IrrlichtLime.KeyAction,IrrlichtLime.KeyCode)">
			<summary>Add key mapping.</summary>
		</member>
		<member name="M:IrrlichtLime.KeyMap.#ctor">
			<summary>Constructs empty key map.</summary>
		</member>
		<member name="P:IrrlichtLime.KeyMap.Map">
			<summary>Key map dictionary.</summary>
		</member>
		<member name="T:IrrlichtLime.Lime">
			<summary>IrrlichtLime core class. Provides wrapper common functionality.</summary>
		</member>
		<member name="P:IrrlichtLime.Lime.Version">
			<summary>IrrlichtLime version.</summary>
		</member>
		<member name="T:IrrlichtLime.Logger">
			<summary>Class for logging messages, warnings and errors.</summary>
		</member>
		<member name="M:IrrlichtLime.Logger.Log(System.String)">
			<summary>Prints out a text into the log.</summary>
			<param name="text">Text to print out.</param>
		</member>
		<member name="M:IrrlichtLime.Logger.Log(System.String,System.String,IrrlichtLime.LogLevel)">
			<summary>Prints out a text into the log.</summary>
			<param name="text">Text to print out.</param>
			<param name="hint">Additional info. This string is added after a " :" to the string.</param>
			<param name="level">Log level of the text. Texts are filtered using this level. If you want to be a text displayed, independent on what level filter is set, use LogLovel.None.</param>
		</member>
		<member name="M:IrrlichtLime.Logger.Log(System.String,IrrlichtLime.LogLevel)">
			<summary>Prints out a text into the log.</summary>
			<param name="text">Text to print out.</param>
			<param name="level">Log level of the text. Texts are filtered using this level. If you want to be a text displayed, independent on what level filter is set, use LogLovel.None.</param>
		</member>
		<member name="P:IrrlichtLime.Logger.LogLevel">
			<summary>Current log level. With this value, texts which are sent to the logger are filtered out.

Default value: LogLevel.Warning.</summary>
		</member>
		<member name="T:IrrlichtLime.LogLevel">
			<summary>Possible log levels.</summary>
		</member>
		<member name="F:IrrlichtLime.LogLevel.Debug">
			<summary>Used for printing information helpful in debugging.</summary>
		</member>
		<member name="F:IrrlichtLime.LogLevel.Error">
			<summary>Low log level, only errors are printed into the log.</summary>
		</member>
		<member name="F:IrrlichtLime.LogLevel.Information">
			<summary>High log level, warnings, errors and important information texts are printed out.</summary>
		</member>
		<member name="F:IrrlichtLime.LogLevel.None">
			<summary>Nothing is printed out to the log.</summary>
		</member>
		<member name="F:IrrlichtLime.LogLevel.Warning">
			<summary>Default log level, warnings and errors are printed out.</summary>
		</member>
		<member name="T:IrrlichtLime.MouseEventType">
			<summary>All mouse input events.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.LeftDoubleClick">
			<summary>Left mouse button double click. This event is generated after the second LeftDown event.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.LeftDown">
			<summary>Left mouse button was pressed down.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.LeftTripleClick">
			<summary>Left mouse button triple click. This event is generated after the third LeftDown event.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.LeftUp">
			<summary>Left mouse button was left up.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.MiddleDoubleClick">
			<summary>Middle mouse button double click. This event is generated after the second MiddleDown event.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.MiddleDown">
			<summary>Middle mouse button was pressed down.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.MiddleTripleClick">
			<summary>Middle mouse button triple click. This event is generated after the third MiddleDown event.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.MiddleUp">
			<summary>Middle mouse button was left up.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.Move">
			<summary>The mouse cursor changed its position.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.RightDoubleClick">
			<summary>Right mouse button double click. This event is generated after the second RightDown event.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.RightDown">
			<summary>Right mouse button was pressed down.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.RightTripleClick">
			<summary>Right mouse button triple click. This event is generated after the third RightDown event.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.RightUp">
			<summary>Right mouse button was left up.</summary>
		</member>
		<member name="F:IrrlichtLime.MouseEventType.Wheel">
			<summary>The mouse wheel was moved. Use Wheel value in event data to find out in what direction and how fast.</summary>
		</member>
		<member name="T:IrrlichtLime.OSOperator">
			<summary>The Operating system operator provides operation system specific methods and informations.</summary>
		</member>
		<member name="P:IrrlichtLime.OSOperator.ClipboardText">
			<summary>Text in the clipboard.</summary>
		</member>
		<member name="P:IrrlichtLime.OSOperator.MemoryFreeKb">
			<summary>Total system RAM in kilobytes.</summary>
		</member>
		<member name="P:IrrlichtLime.OSOperator.MemoryTotalKb">
			<summary>Available system RAM in kilobytes.</summary>
		</member>
		<member name="P:IrrlichtLime.OSOperator.OSVersion">
			<summary>Operation system version.</summary>
		</member>
		<member name="P:IrrlichtLime.OSOperator.ProcessorSpeedMHz">
			<summary>Processor speed in megahertz.</summary>
		</member>
		<member name="T:IrrlichtLime.ReferenceCounted">
			<summary>Base class of most objects of the Irrlicht Engine.

This class provides reference counting through the methods Grab() and Drop(). It also is able to store a debug string for every instance of an object. Most objects of the Irrlicht Engine are derived from ReferenceCounted, and so they are reference counted.

When you create an object in the Irrlicht Engine, calling a method which starts with 'create', an object is created, and you get a pointer to the new object. If you no longer need the object, you have to call Drop(). This will destroy the object, if Grab() was not called in another part of you program, because this part still needs the object. Note, that you only need to call Drop() to the object, if you created it, and the method name starts with 'create'.</summary>
		</member>
		<member name="P:IrrlichtLime.ReferenceCounted.DebugName">
			<summary>The debug name of the object. This value may only be set and changed by the object itself. This property has value only when used in Debug mode.</summary>
		</member>
		<member name="M:IrrlichtLime.ReferenceCounted.Drop">
			<summary>Drops the object. Decrements the reference counter by one.

The ReferenceCounted class provides a basic reference counting mechanism with its methods Grab() and Drop(). Most objects of the Irrlicht Engine are derived from ReferenceCounted, and so they are reference counted.

When you create an object in the Irrlicht Engine, calling a method which starts with 'create', an object is created, and you get a pointer to the new object. If you no longer need the object, you have to call Drop(). This will destroy the object, if Grab() was not called in another part of you program, because this part still needs the object. Note, that you only need to call Drop() to the object, if you created it, and the method name starts with 'create'.</summary>
			<returns>True, if the object was deleted.</returns>
		</member>
		<member name="M:IrrlichtLime.ReferenceCounted.Grab">
			<summary>Grabs the object. Increments the reference counter by one.

Someone who calls Grab() to an object, should later also call Drop() to it. If an object never gets as much Drop() as Grab() calls, it will never be destroyed.

The ReferenceCounted class provides a basic reference counting mechanism with its methods Grab() and Drop(). Most objects of the Irrlicht Engine are derived from ReferenceCounted, and so they are reference counted.

When you create an object in the Irrlicht Engine, calling a method which starts with 'create', an object is created, and you get a pointer to the new object. If you no longer need the object, you have to call Drop(). This will destroy the object, if Grab() was not called in another part of you program, because this part still needs the object. Note, that you only need to call Drop() to the object, if you created it, and the method name starts with 'create'.</summary>
		</member>
		<member name="P:IrrlichtLime.ReferenceCounted.ReferenceCount">
			<summary>Current value of the reference counter.</summary>
		</member>
		<member name="T:IrrlichtLime.Timer">
			<summary>Class for getting and manipulating the virtual time.</summary>
		</member>
		<member name="P:IrrlichtLime.Timer.IsStopped">
			<summary>Returns if the virtual timer is currently stopped.</summary>
		</member>
		<member name="P:IrrlichtLime.Timer.RealTime">
			<summary>Current real time in milliseconds of the system.

This value does not start with 0 when the application starts. For example in one implementation the value returned could be the amount of milliseconds which have elapsed since the system was started.</summary>
		</member>
		<member name="P:IrrlichtLime.Timer.Speed">
			<summary>Speed of the timer.

The speed is the factor with which the time is running faster or slower then the real system time.</summary>
		</member>
		<member name="M:IrrlichtLime.Timer.Start">
			<summary>Starts the virtual timer.

The timer is reference counted, which means everything which calls Stop() will also have to call Start(), otherwise the timer may not start/stop correctly again.</summary>
		</member>
		<member name="M:IrrlichtLime.Timer.Stop">
			<summary>Stops the virtual timer.

The timer is reference counted, which means everything which calls Stop() will also have to call Start(), otherwise the timer may not start/stop correctly again.</summary>
		</member>
		<member name="M:IrrlichtLime.Timer.Tick">
			<summary>Advances the virtual time.

Makes the virtual timer update the time value based on the real time. This is called automatically when calling IrrlichtDevice.Run(), but you can call it manually if you don't use this method.</summary>
		</member>
		<member name="P:IrrlichtLime.Timer.Time">
			<summary>Current virtual time in milliseconds.

This value starts with 0 and can be manipulated: value can be set, you can call Start() or Stop() or change Speed. If you need the system time, use RealTime.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.AABBox">
			<summary>Axis aligned bounding box in 3d dimensional space.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.#ctor">
			<summary>Default Constructor.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Constructor with min edge and max edge.</summary>
			<param name="min">Min edge.</param>
			<param name="max">Max edge.</param>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
			<summary>Constructor with min edge and max edge as single values, not vectors.</summary>
			<param name="minx">X coordinate of min edge.</param>
			<param name="miny">Y coordinate of min edge.</param>
			<param name="minz">Z coordinate of min edge.</param>
			<param name="maxx">X coordinate of max edge.</param>
			<param name="maxy">Y coordinate of max edge.</param>
			<param name="maxz">Z coordinate of max edge.</param>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.#ctor(IrrlichtLime.Core.Vector3Df)">
			<summary>Constructor with only one point.</summary>
			<param name="point">Min and max edge.</param>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.AddInternalBox(IrrlichtLime.Core.AABBox)">
			<summary>Adds another bounding box.</summary>
			<param name="b">Other bounding box to add into this box.</param>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.AddInternalPoint(IrrlichtLime.Core.Vector3Df)">
			<summary>Adds a point to the bounding box. The box grows bigger, if point is outside of the box.</summary>
			<param name="p">Point to add into the box.</param>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.AddInternalPoint(System.Single,System.Single,System.Single)">
			<summary>Adds a point to the bounding box. The box grows bigger, if point is outside of the box.</summary>
			<param name="x">X coordinate of the point to add to this box.</param>
			<param name="y">Y coordinate of the point to add to this box.</param>
			<param name="z">Z coordinate of the point to add to this box.</param>
		</member>
		<member name="P:IrrlichtLime.Core.AABBox.Area">
			<summary>The surface area of the box in squared units.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.AABBox.Center">
			<summary>Center of the bounding box.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.AABBox.Empty">
			<summary>Check if the box is empty. This means that there is no space between the min and max edge.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.AABBox.Extent">
			<summary>Extent of the box (maximal distance of two points in the box).</summary>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.IsInside(IrrlichtLime.Core.AABBox)">
			<summary>Check if this box is completely inside the 'other' box.</summary>
			<param name="b">Other box to check against.</param>
			<returns>True if this box is completly inside the other box, otherwise false.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.IsInside(IrrlichtLime.Core.Vector3Df)">
			<summary>Determines if a point is within this box. Border is included (is part of the box)!</summary>
			<param name="p">Point to check.</param>
			<returns>True if the point is within the box and false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.IsInsideFully(IrrlichtLime.Core.Vector3Df)">
			<summary>Determines if a point is within this box and not its borders. Border is excluded (not part of the box)!</summary>
			<param name="p">Point to check.</param>
			<returns>True if the point is within the box and false if not.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.AABBox.MaxEdge">
			<summary>The far edge.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.AABBox.MinEdge">
			<summary>The near edge.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.Repair">
			<summary>Repairs the box. Necessary if for example MinEdge and MaxEdge are swapped.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.Set(IrrlichtLime.Core.AABBox)">
			<summary>Sets the bounding box.</summary>
			<param name="newBox">New box to set this one to.</param>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.Set(IrrlichtLime.Core.Vector3Df)">
			<summary>Sets the bounding box to a one-point box.</summary>
			<param name="newPoint">New point.</param>
		</member>
		<member name="M:IrrlichtLime.Core.AABBox.Set(System.Single,System.Single,System.Single)">
			<summary>Sets the bounding box to a one-point box.</summary>
			<param name="x">X coordinate of the point.</param>
			<param name="y">Y coordinate of the point.</param>
			<param name="z">Z coordinate of the point.</param>
		</member>
		<member name="P:IrrlichtLime.Core.AABBox.Volume">
			<summary>The volume enclosed by the box in cubed units.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Dimension2Df">
			<summary>Specifies a 2 dimensional float size.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Dimension2Df.Area">
			<summary>Area of the dimension: Width x Height.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.#ctor">
			<summary>Default constructor for empty dimension.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.#ctor(IrrlichtLime.Core.Dimension2Df)">
			<summary>Creates separete copy.</summary>
			<param name="copy">Value to copy.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.#ctor(System.Single,System.Single)">
			<summary>Creates dimension using Width and Height.</summary>
			<param name="width">Width.</param>
			<param name="height">Height.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.#ctor(System.Single)">
			<summary>Creates dimension using same width and height (a square).</summary>
			<param name="widthAndHeight">One value for both Width and Height.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.GetInterpolated(IrrlichtLime.Core.Dimension2Df,System.Single)">
			<summary>Get the interpolated dimension.</summary>
			<param name="other">Other dimension to interpolate with.</param>
			<param name="d">Value between 0.0f and 1.0f.</param>
			<returns>Interpolated dimension.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.GetOptimalSize">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.GetOptimalSize(System.Boolean)">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default: true.</param>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.GetOptimalSize(System.Boolean,System.Boolean)">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default: true.</param>
			<param name="requireSquare">Makes width==height in the result. Default: false.</param>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.GetOptimalSize(System.Boolean,System.Boolean,System.Boolean)">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default: true.</param>
			<param name="requireSquare">Makes width==height in the result. Default: false.</param>
			<param name="larger">Choose whether the result is larger or smaller than the current dimension. If one dimension need not be changed it is kept with any value of larger. Default: true.</param>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.GetOptimalSize(System.Boolean,System.Boolean,System.Boolean,System.UInt32)">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default: true.</param>
			<param name="requireSquare">Makes width==height in the result. Default: false.</param>
			<param name="larger">Choose whether the result is larger or smaller than the current dimension. If one dimension need not be changed it is kept with any value of larger. Default: true.</param>
			<param name="maxValue">Maximum texturesize. if value &gt; 0 size is clamped to maxValue. Default: 0.</param>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Dimension2Df.Height">
			<summary>Height of the dimension.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.Set(IrrlichtLime.Core.Dimension2Df)">
			<summary>Set to new value using another dimension.</summary>
			<param name="copy">Another dimension.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Df.Set(System.Single,System.Single)">
			<summary>Set to new value using new Width and Height.</summary>
			<param name="width">New Width.</param>
			<param name="height">New Height.</param>
		</member>
		<member name="P:IrrlichtLime.Core.Dimension2Df.Width">
			<summary>Width of the dimension.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Dimension2Di">
			<summary>Specifies a 2 dimensional integer size.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Dimension2Di.Area">
			<summary>Area of the dimension: Width x Height.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.#ctor">
			<summary>Default constructor for empty dimension.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.#ctor(IrrlichtLime.Core.Dimension2Di)">
			<summary>Creates separete copy.</summary>
			<param name="copy">Value to copy.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.#ctor(System.Int32,System.Int32)">
			<summary>Creates dimension using Width and Height.</summary>
			<param name="width">Width.</param>
			<param name="height">Height.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.#ctor(System.Int32)">
			<summary>Creates dimension using same width and height (a square).</summary>
			<param name="widthAndHeight">One value for both Width and Height.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.GetInterpolated(IrrlichtLime.Core.Dimension2Di,System.Single)">
			<summary>Get the interpolated dimension.</summary>
			<param name="other">Other dimension to interpolate with.</param>
			<param name="d">Value between 0.0f and 1.0f.</param>
			<returns>Interpolated dimension.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize(System.Boolean)">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default: true.</param>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize(System.Boolean,System.Boolean)">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default: true.</param>
			<param name="requireSquare">Makes width==height in the result. Default: false.</param>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize(System.Boolean,System.Boolean,System.Boolean)">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default: true.</param>
			<param name="requireSquare">Makes width==height in the result. Default: false.</param>
			<param name="larger">Choose whether the result is larger or smaller than the current dimension. If one dimension need not be changed it is kept with any value of larger. Default: true.</param>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.GetOptimalSize(System.Boolean,System.Boolean,System.Boolean,System.UInt32)">
			<summary>Get the optimal size according to some properties.

This is a function often used for texture dimension calculations. The function returns the next larger or smaller dimension which is a power-of-two dimension (2^n,2^m) and/or square (Width=Height).</summary>
			<param name="requirePowerOfTwo">Forces the result to use only powers of two as values. Default: true.</param>
			<param name="requireSquare">Makes width==height in the result. Default: false.</param>
			<param name="larger">Choose whether the result is larger or smaller than the current dimension. If one dimension need not be changed it is kept with any value of larger. Default: true.</param>
			<param name="maxValue">Maximum texturesize. if value &gt; 0 size is clamped to maxValue. Default: 0.</param>
			<returns>The optimal dimension under the given constraints.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Dimension2Di.Height">
			<summary>Height of the dimension.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.Set(IrrlichtLime.Core.Dimension2Di)">
			<summary>Set to new value using another dimension.</summary>
			<param name="copy">Another dimension.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Dimension2Di.Set(System.Int32,System.Int32)">
			<summary>Set to new value using new Width and Height.</summary>
			<param name="width">New Width.</param>
			<param name="height">New Height.</param>
		</member>
		<member name="P:IrrlichtLime.Core.Dimension2Di.Width">
			<summary>Width of the dimension.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Line3Df">
			<summary>3D line between two points with intersection methods.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Line3Df.End">
			<summary>End point of line.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Line3Df.GetClosestPoint(IrrlichtLime.Core.Vector3Df)">
			<summary>Get the closest point on this line to a point.</summary>
			<param name="point">The point to compare to.</param>
			<returns>The nearest point which is part of the line.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Line3Df.GetIntersectionWithSphere(IrrlichtLime.Core.Vector3Df,System.Single,System.Double@)">
			<summary>Check if the line intersects with a shpere.</summary>
			<param name="sphereOrigin">Origin of the shpere.</param>
			<param name="sphereRadius">Radius of the sphere.</param>
			<param name="distance">The distance to the first intersection point.</param>
			<returns>True if there is an intersection. If there is one, the distance to the first intersection point is stored in outdistance.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Line3Df.IsPointBetweenStartAndEnd(IrrlichtLime.Core.Vector3Df)">
			<summary>Check if the given point is between start and end of the line.

Assumes that the point is already somewhere on the line.</summary>
			<param name="point">The point to test.</param>
			<returns>True if point is on the line between start and end, else false.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Line3Df.Length">
			<summary>Length of line.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Line3Df.LengthSQ">
			<summary>Squared length of line: Length^2.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Line3Df.#ctor">
			<summary>Default constructor. Line from (0,0,0) to (1,1,1).</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Line3Df.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Constructor with two points as vectors.</summary>
			<param name="start">Start point.</param>
			<param name="end">End point.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Line3Df.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
			<summary>Constructor with two points.</summary>
			<param name="startX">Start point X coord.</param>
			<param name="startY">Start point Y coord.</param>
			<param name="startZ">Start point Z coord.</param>
			<param name="endX">End point X coord.</param>
			<param name="endY">End point Y coord.</param>
			<param name="endZ">End point Z coord.</param>
		</member>
		<member name="P:IrrlichtLime.Core.Line3Df.Middle">
			<summary>Center of line.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Line3Df.Set(IrrlichtLime.Core.Line3Df)">
			<summary>Set this line to new line given as parameter.</summary>
			<param name="newLine">Line to copy.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Line3Df.Set(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Set this line to a new line going through the two points as vectors.</summary>
			<param name="newStart">Start point.</param>
			<param name="newEnd">End point.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Line3Df.Set(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
			<summary>Set this line to a new line going through the two points.</summary>
			<param name="newStartX">New start point X coord.</param>
			<param name="newStartY">New start point Y coord.</param>
			<param name="newStartZ">New start point Z coord.</param>
			<param name="newEndX">New end point X coord.</param>
			<param name="newEndY">New end point Y coord.</param>
			<param name="newEndZ">New end point Z coord.</param>
		</member>
		<member name="P:IrrlichtLime.Core.Line3Df.Start">
			<summary>Start point of line.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Line3Df.Vector">
			<summary>Vector of line.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Matrix">
			<summary>4x4 matrix. Mostly used as transformation matrix for 3d calculations.

The matrix is a D3D style matrix, row major with translations in the 4th row.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildAxisAlignedBillboard(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Builds a matrix which rotates a source vector to a look vector over an arbitrary axis.</summary>
			<param name="camPos">Viewer position in world coords.</param>
			<param name="center">Object position in world coords and rotation pivot.</param>
			<param name="translation">Object final translation from center.</param>
			<param name="axis">Axis to rotate about.</param>
			<param name="from">Source vector to rotate from.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildCameraLookAtMatrixLH(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Builds a left-handed look-at matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildCameraLookAtMatrixRH(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Builds a right-handed look-at matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildNDCToDCMatrix(IrrlichtLime.Core.Recti,System.Single)">
			<summary>Builds a matrix which transforms a normalized Device Coordinate to Device Coordinates.

Used to scale (-1,-1)-(1,1) to viewport size, for example to (0,0)-(639,479).</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixOrthoLH(System.Single,System.Single,System.Single,System.Single)">
			<summary>Builds a left-handed orthogonal projection matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixOrthoRH(System.Single,System.Single,System.Single,System.Single)">
			<summary>Builds a right-handed orthogonal projection matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveFovLH(System.Single,System.Single,System.Single,System.Single)">
			<summary>Builds a left-handed perspective projection matrix based on a field of view.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveFovRH(System.Single,System.Single,System.Single,System.Single)">
			<summary>Builds a right-handed perspective projection matrix based on a field of view.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveLH(System.Single,System.Single,System.Single,System.Single)">
			<summary>Builds a left-handed perspective projection matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildProjectionMatrixPerspectiveRH(System.Single,System.Single,System.Single,System.Single)">
			<summary>Builds a right-handed perspective projection matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildRotateFromTo(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Builds a matrix that rotates from one vector to another.</summary>
			<param name="from">Vector to rotate from.</param>
			<param name="to">Vector to rotate to.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildShadowMatrix(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Plane3Df)">
			<summary>Builds a matrix that flattens geometry into a plane.</summary>
			<param name="light">Light source.</param>
			<param name="plane">Plane into which the geometry if flattened into.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildShadowMatrix(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Plane3Df,System.Single)">
			<summary>Builds a matrix that flattens geometry into a plane.</summary>
			<param name="light">Light source.</param>
			<param name="plane">Plane into which the geometry if flattened into.</param>
			<param name="point">Value between 0 and 1, describing the light source. If this is 1, it is a point light, if it is 0, it is a directional light. Default: 1.0f.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.BuildTextureTransform(System.Single,IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
			<summary>Set to a texture transformation matrix with the given parameters.

Generate texture coordinates as linear functions so that: u = Ux*x + Uy*y + Uz*z + Uw v = Vx*x + Vy*y + Vz*z + Vw The matrix M for this case is: Ux Vx 0 0 Uy Vy 0 0 Uz Vz 0 0 Uw Vw 0 0.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Matrix.DefinitelyIdentity">
			<summary>Gets/sets if the matrix is definitely identity matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.GetElement(System.Int32)">
			<summary>Gets separate element of the matrix by its index.</summary>
			<param name="index">Index of matrix element from 0 to 15.</param>
			<returns>Value of matrix element.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.GetElement(System.Int32,System.Int32)">
			<summary>Gets separate element of the matrix by its coord.</summary>
			<param name="row">Row index of matrix element from 0 to 3.</param>
			<param name="column">Column index of matrix element from 0 to 3.</param>
			<returns>Value of matrix element.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.GetInterpolated(IrrlichtLime.Core.Matrix,System.Single)">
			<summary>Creates a new matrix as interpolated matrix from two other ones.</summary>
			<param name="other">Other matrix to interpolate with.</param>
			<param name="time">Must be a value between 0 and 1.</param>
			<returns>Interpolated matrix.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.GetInverse">
			<summary>Gets the inversed matrix of this one. Calculates the inverse of this matrix. The inverse is calculated using Cramers rule. Note: if no inverse exists then null is returned.</summary>
			<returns>Inverse matrix or null if not applicable.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.GetInversePrimitive">
			<summary>Inverts a primitive matrix which only contains a translation and a rotation. Note: if no inverse exists then null is returned.</summary>
			<returns>Inverse matrix or null if not applicable.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Matrix.Identity">
			<summary>Identity matrix.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Matrix.IdentityIntegerBase">
			<summary>True if the matrix is the identity matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.InverseRotateVector(IrrlichtLime.Core.Vector3Df@)">
			<summary>Rotate a vector by the inverse of the rotation part of this matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.InverseTranslateVector(IrrlichtLime.Core.Vector3Df@)">
			<summary>Translate a vector by the inverse of the translation part of this matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.MakeIdentity">
			<summary>Set matrix to identity.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.MakeInverse">
			<summary>Calculates inverse of matrix. Slow.</summary>
			<returns>False if there is no inverse matrix.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.#ctor">
			<summary>Default constructor. Creates identity matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.MultiplyWith1x4Matrix(System.Single[])">
			<summary>Multiplies this matrix by a 1x4 matrix.</summary>
			<param name="m1x4">1x4 matrix. This array must contain 4 elements.</param>
		</member>
		<member name="P:IrrlichtLime.Core.Matrix.Orthogonal">
			<summary>True if the matrix is orthogonal.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.RotateVector(IrrlichtLime.Core.Vector3Df)">
			<summary>Rotate a vector by the rotation part of this matrix.</summary>
			<param name="vect">Vector to rotate.</param>
			<returns>Rotated vector.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Matrix.Rotation">
			<summary>Matrix rotation in degrees. Note that it does not necessarily return the *same* Euler angles as those previously set, but the rotation will be equivalent, i.e. will have the same result when used to rotate a vector or node.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Matrix.Scale">
			<summary>Absolute values of the scales of the matrix. Note that this always returns the absolute (positive) values.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetByProduct(IrrlichtLime.Core.Matrix,IrrlichtLime.Core.Matrix)">
			<summary>Set this matrix to the product of two matrices. Multiply by another matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetByProductNoCheck(IrrlichtLime.Core.Matrix,IrrlichtLime.Core.Matrix)">
			<summary>Set this matrix to the product of two matrices. Multiply by another matrix. No optimization used, use it if you know you never have an identity matrix.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetElement(System.Int32,System.Single)">
			<summary>Sets separate element of the matrix by its index.</summary>
			<param name="index">Index of matrix element from 0 to 15.</param>
			<param name="value">Value of matrix element.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetElement(System.Int32,System.Int32,System.Single)">
			<summary>Sets separate element of the matrix by its coord.</summary>
			<param name="row">Row index of matrix element from 0 to 3.</param>
			<param name="column">Column index of matrix element from 0 to 3.</param>
			<param name="value">Value of matrix element.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetElementArray(System.Single[])">
			<summary>Sets all matrix elements at once.</summary>
			<param name="values">Array of new matrix elements. Must contain 16 elements.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetInverseRotationDegrees(IrrlichtLime.Core.Vector3Df)">
			<summary>Make an inverted rotation matrix from Euler angles in degrees.

The 4th row and column are unmodified.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetInverseRotationRadians(IrrlichtLime.Core.Vector3Df)">
			<summary>Make an inverted rotation matrix from Euler angles in radians.

The 4th row and column are unmodified.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetInverseTranslation(IrrlichtLime.Core.Vector3Df)">
			<summary>Set the inverse translation of the current matrix. Will erase any previous values.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetRotationCenter(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Builds a combined matrix which translates to a center before rotation and translates from origin afterwards.</summary>
			<param name="center">Position to rotate around.</param>
			<param name="translate">Translation applied after the rotation.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetRotationRadians(IrrlichtLime.Core.Vector3Df)">
			<summary>Make a rotation matrix from Euler angles. The 4th row and column are unmodified.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetTextureRotationCenter(System.Single)">
			<summary>Set texture transformation rotation.

Rotate about z axis, recenter at (0.5,0.5). Doesn't clear other elements than those affected.</summary>
			<param name="radAngle">Angle in radians.</param>
			<returns>Altered matrix.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetTextureScale(System.Single,System.Single)">
			<summary>Set texture transformation scale.

Doesn't clear other elements than those affected.</summary>
			<param name="sx">Scale factor on x axis.</param>
			<param name="sy">Scale factor on y axis.</param>
			<returns>Altered matrix.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetTextureScaleCenter(System.Single,System.Single)">
			<summary>Set texture transformation scale, and recenter at (0.5,0.5).

Doesn't clear other elements than those affected.</summary>
			<param name="sx">Scale factor on x axis.</param>
			<param name="sy">Scale factor on y axis.</param>
			<returns>Altered matrix.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetTextureTranslate(System.Single,System.Single)">
			<summary>Set texture transformation translation.

Doesn't clear other elements than those affected.</summary>
			<param name="x">Offset on x axis.</param>
			<param name="y">Offset on y axis.</param>
			<returns>Altered matrix.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.SetTextureTranslateTransposed(System.Single,System.Single)">
			<summary>Set texture transformation translation, using a transposed representation.

Doesn't clear other elements than those affected.</summary>
			<param name="x">Offset on x axis.</param>
			<param name="y">Offset on y axis.</param>
			<returns>Altered matrix.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.ToArray">
			<summary>Returns matrix as array.</summary>
			<returns>Array containing 16 elements of matrix.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.TransformBox(IrrlichtLime.Core.AABBox@)">
			<summary>Transforms a axis aligned bounding box.

The result box of this operation may not be accurate at all. For correct results, use TransformBoxEx().</summary>
			<param name="box">Box to transform.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.TransformBoxEx(IrrlichtLime.Core.AABBox@)">
			<summary>Transforms a axis aligned bounding box.

Transforms a axis aligned bounding box more accurately than TtransformBox().

The result box of this operation should by accurate, but this operation is slower than TransformBox().</summary>
			<param name="box">Box to transform.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.TransformPlane(IrrlichtLime.Core.Plane3Df@)">
			<summary>Transforms a plane by this matrix.</summary>
			<param name="plane">Plane to transform.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.TransformVector(IrrlichtLime.Core.Vector3Df@)">
			<summary>Transforms a vector by this matrix.</summary>
			<param name="vect">Vector to transform.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Matrix.TranslateVector(IrrlichtLime.Core.Vector3Df@)">
			<summary>Translates a vector by the translation part of this matrix.</summary>
			<param name="vect">Vector to translate.</param>
		</member>
		<member name="P:IrrlichtLime.Core.Matrix.Translation">
			<summary>Matrix translation.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Matrix.Transposed">
			<summary>Transposed matrix.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Plane3Df">
			<summary>Plane class with some intersection testing methods.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Plane3Df.D">
			<summary>Distance from origin.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.GetDistanceTo(IrrlichtLime.Core.Vector3Df)">
			<summary>Get the distance to a point.

Note that this only works if the normal is normalized.</summary>
			<param name="point">Target point.</param>
			<returns>The distnace from point to this plane.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.GetIntersectionWithLimitedLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df@)">
			<summary>Get an intersection with a 3d line, limited between two 3d points.</summary>
			<param name="linePoint1">Point 1 of the line.</param>
			<param name="linePoint2">Point 2 of the line.</param>
			<param name="intersection">Place to store the intersection point, if there is one. Note: this output value has meaning only if this method returns true.</param>
			<returns>True if there was an intersection, false if there was not.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.GetIntersectionWithLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df@)">
			<summary>Get an intersection with a 3d line (line defined by start point and direction, so actually this is a ray).</summary>
			<param name="linePoint">Point of the line to intersect with.</param>
			<param name="lineVect">Vector of the line to intersect with.</param>
			<param name="intersection">Place to store the intersection point, if there is one. Note: this output value has meaning only if this method returns true.</param>
			<returns>True if there was an intersection, false if there was not.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.GetIntersectionWithPlane(IrrlichtLime.Core.Plane3Df,IrrlichtLime.Core.Vector3Df@,IrrlichtLime.Core.Vector3Df@)">
			<summary>Intersects this plane with another.</summary>
			<param name="other">Other plane to intersect with.</param>
			<param name="intersectionLinePoint">Base point of intersection line.</param>
			<param name="intersectionLineVector">Vector of intersection.</param>
			<returns>True if there is a intersection, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.GetIntersectionWithPlanes(IrrlichtLime.Core.Plane3Df,IrrlichtLime.Core.Plane3Df,IrrlichtLime.Core.Vector3Df@)">
			<summary>Get the intersection point with two other planes if there is one.</summary>
			<param name="other1">Other plane 1 to intersect with.</param>
			<param name="other2">Other plane 2 to intersect with.</param>
			<param name="intersectionPoint">Intersection result.</param>
			<returns>True if there is a intersection, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.GetKnownIntersectionWithLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Get percentage (value from 0.0 to 1.0) of line between two points where an intersection with this plane happens.

Only useful if known that there is an intersection.</summary>
			<param name="linePoint1">Point1 of the line to intersect with.</param>
			<param name="linePoint2">Point2 of the line to intersect with.</param>
			<returns>Where on a line between two points an intersection with this plane happened. For example, 0.5 is returned if the intersection happened exactly in the middle of the two points.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.Intersects(IrrlichtLime.Core.Plane3Df)">
			<summary>Tests if there is an intersection with the other plane.</summary>
			<param name="other">Other plane.</param>
			<returns>True if there is an intersection.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.IsFrontFacing(IrrlichtLime.Core.Vector3Df)">
			<summary>Test if the triangle would be front or backfacing from any point.

Thus, this method assumes a camera position from which the triangle is definitely visible when looking into the given direction. Note that this only works if the normal is Normalized. Do not use this method with points as it will give wrong results!</summary>
			<param name="lookDirection">Look direction.</param>
			<returns>True if the plane is front facing and false if it is backfacing.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Plane3Df.MemberPoint">
			<summary>Member point of the plane.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Plane3Df.Normal">
			<summary>Normal vector of the plane.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.Set(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Sets plane by its member point and normal vector.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.Set(IrrlichtLime.Core.Vector3Df,System.Single)">
			<summary>Sets plane by its normal vector and the distance from origin.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Plane3Df.Set(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Sets plane by three points.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Rectf">
			<summary>Rectangular area.

Mostly used by 2D GUI elements and for 2D drawing methods. It has 2 positions instead of position and dimension and a fast method for collision detection with other rectangles and points.

Coordinates are (0,0) for top-left corner, and increasing to the right and to the bottom.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.AddInternalPoint(IrrlichtLime.Core.Vector2Df)">
			<summary>Adds a point to the bounding rectangle.

Causes the rectangle to grow bigger if point is outside of the box.</summary>
			<param name="point">Point to add to the box.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.AddInternalPoint(System.Single,System.Single)">
			<summary>Adds a point to the bounding rectangle.

Causes the rectangle to grow bigger if point is outside of the box.</summary>
			<param name="x">X-Coordinate of the point to add to this box.</param>
			<param name="y">Y-Coordinate of the point to add to this box.</param>
		</member>
		<member name="P:IrrlichtLime.Core.Rectf.Area">
			<summary>Area of the rectangle: Width x Height.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Rectf.Center">
			<summary>Center of the rectangle.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.ClipAgainst(IrrlichtLime.Core.Rectf)">
			<summary>Clips this rectangle with another one.</summary>
			<param name="other">Rectangle to clip with.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.ConstrainTo(IrrlichtLime.Core.Rectf)">
			<summary>Moves this rectangle to fit inside another one.</summary>
			<param name="other">Other rectangle.</param>
			<returns>True on success, false if not possible.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Rectf.Height">
			<summary>Height of the rectangle.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.IsPointInside(IrrlichtLime.Core.Vector2Df)">
			<summary>Checks if a 2d point is within this rectangle.</summary>
			<param name="pos">Position to test.</param>
			<returns>True if the position is within the rectangle, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.IsRectCollided(IrrlichtLime.Core.Rectf)">
			<summary>Checks if the rectangle collides with another rectangle.</summary>
			<param name="other">Other rectangle.</param>
			<returns>True if the rectangles collide.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Rectf.LowerRightCorner">
			<summary>Lower right corner of the rectangle.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.#ctor">
			<summary>Default constructor creating empty rectangle at (0,0).</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.#ctor(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Dimension2Df)">
			<summary>Constructor with upper left corner and dimension.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.#ctor(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
			<summary>Constructor with two corners.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.#ctor(System.Single,System.Single,System.Single,System.Single)">
			<summary>Constructor with two corners.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Rectf.Repair">
			<summary>If the lower right corner of the rect is smaller then the upper left, the points are swapped.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Rectf.UpperLeftCorner">
			<summary>Upper left corner of the rectangle.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Rectf.Valid">
			<summary>Checks if the rectangle is valid to draw.

It would be invalid if the UpperLeftCorner is lower or more right than the LowerRightCorner.

Note: use Repair() to make it valid.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Rectf.Width">
			<summary>Width of the rectangle.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Recti">
			<summary>Rectangular area.

Mostly used by 2D GUI elements and for 2D drawing methods. It has 2 positions instead of position and dimension and a fast method for collision detection with other rectangles and points.

Coordinates are (0,0) for top-left corner, and increasing to the right and to the bottom.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.AddInternalPoint(IrrlichtLime.Core.Vector2Di)">
			<summary>Adds a point to the bounding rectangle.

Causes the rectangle to grow bigger if point is outside of the box.</summary>
			<param name="point">Point to add to the box.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.AddInternalPoint(System.Int32,System.Int32)">
			<summary>Adds a point to the bounding rectangle.

Causes the rectangle to grow bigger if point is outside of the box.</summary>
			<param name="x">X-Coordinate of the point to add to this box.</param>
			<param name="y">Y-Coordinate of the point to add to this box.</param>
		</member>
		<member name="P:IrrlichtLime.Core.Recti.Area">
			<summary>Area of the rectangle: Width x Height.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Recti.Center">
			<summary>Center of the rectangle.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.ClipAgainst(IrrlichtLime.Core.Recti)">
			<summary>Clips this rectangle with another one.</summary>
			<param name="other">Rectangle to clip with.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.ConstrainTo(IrrlichtLime.Core.Recti)">
			<summary>Moves this rectangle to fit inside another one.</summary>
			<param name="other">Other rectangle.</param>
			<returns>True on success, false if not possible.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Recti.Height">
			<summary>Height of the rectangle.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.IsPointInside(IrrlichtLime.Core.Vector2Di)">
			<summary>Checks if a 2d point is within this rectangle.</summary>
			<param name="pos">Position to test.</param>
			<returns>True if the position is within the rectangle, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.IsRectCollided(IrrlichtLime.Core.Recti)">
			<summary>Checks if the rectangle collides with another rectangle.</summary>
			<param name="other">Other rectangle.</param>
			<returns>True if the rectangles collide.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Recti.LowerRightCorner">
			<summary>Lower right corner of the rectangle.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.#ctor">
			<summary>Default constructor creating empty rectangle at (0,0).</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.#ctor(IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Dimension2Di)">
			<summary>Constructor with upper left corner and dimension.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.#ctor(IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Vector2Di)">
			<summary>Constructor with two corners.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Constructor with two corners.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Recti.Repair">
			<summary>If the lower right corner of the rect is smaller then the upper left, the points are swapped.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Recti.UpperLeftCorner">
			<summary>Upper left corner of the rectangle.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Recti.Valid">
			<summary>Checks if the rectangle is valid to draw.

It would be invalid if the UpperLeftCorner is lower or more right than the LowerRightCorner.

Note: use Repair() to make it valid.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Recti.Width">
			<summary>Width of the rectangle.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Triangle3Df">
			<summary>3d triangle class for doing collision detection and other things.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Triangle3Df.A">
			<summary>Point A of the triangle.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Triangle3Df.Area">
			<summary>Get the area of the triangle.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Triangle3Df.B">
			<summary>Point B of the triangle.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Triangle3Df.C">
			<summary>Point C of the triangle.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.GetClosestPointOnTriangle(IrrlichtLime.Core.Vector3Df)">
			<summary>Get the closest point on a triangle to a point on the same plane.</summary>
			<param name="point">Point which must be on the same plane as the triangle.</param>
			<returns>The closest point of the triangle.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.GetIntersectionOfPlaneWithLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df@)">
			<summary>Calculates the intersection between a 3d line (line defined by start point and direction, so actually this is a ray) and the plane the triangle is on.</summary>
			<param name="linePoint">Point of the line to intersect with.</param>
			<param name="lineVect">Vector of the line to intersect with.</param>
			<param name="intersection">Place to store the intersection point, if there is one.</param>
			<returns>True if there was an intersection, else false.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.GetIntersectionWithLimitedLine(IrrlichtLime.Core.Line3Df,IrrlichtLime.Core.Vector3Df@)">
			<summary>Get an intersection with a 3d line.</summary>
			<param name="line">Line to intersect with.</param>
			<param name="intersection">Place to store the intersection point, if there is one.</param>
			<returns>True if there was an intersection, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.GetIntersectionWithLine(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df@)">
			<summary>Get an intersection with a 3d line.

Please note that also points are returned as intersection which are on the line, but not between the start and end point of the line. If you want the returned point be between start and end use GetIntersectionWithLimitedLine().</summary>
			<param name="linePoint">Point of the line to intersect with.</param>
			<param name="lineVect">Vector of the line to intersect with.</param>
			<param name="intersection">Place to store the intersection point, if there is one.</param>
			<returns>True if there was an intersection, false if there was not.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.IsFrontFacing(IrrlichtLime.Core.Vector3Df)">
			<summary>Test if the triangle would be front or backfacing from any point.

Thus, this method assumes a camera position from which the triangle is definitely visible when looking at the given direction. Do not use this method with points as it will give wrong results!</summary>
			<param name="lookDirection">Look direction.</param>
			<returns>True if the plane is front facing and false if it is backfacing.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.IsPointInside(IrrlichtLime.Core.Vector3Df)">
			<summary>Check if a point is inside the triangle. Assumes that this point is already on the plane of the triangle.</summary>
			<param name="point">Point to test.</param>
			<returns>True if the point is inside the triangle, otherwise false.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.IsPointInsideFast(IrrlichtLime.Core.Vector3Df)">
			<summary>Check if a point is inside the triangle. Assumes that this point is already on the plane of the triangle.

This method is an implementation of the example used in a paper by Kasper Fauerby original written by Keidy from Mr-Gamemaker.</summary>
			<param name="point">Point to test.</param>
			<returns>True if point is inside the triangle, otherwise false.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.IsTotalInsideBox(IrrlichtLime.Core.AABBox)">
			<summary>Determines if the triangle is totally inside a bounding box.</summary>
			<param name="box">Box to check.</param>
			<returns>True if triangle is within the box, otherwise false.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.IsTotalOutsideBox(IrrlichtLime.Core.AABBox)">
			<summary>Determines if the triangle is totally outside a bounding box.</summary>
			<param name="box">Box to check.</param>
			<returns>True if triangle is outside the box, otherwise false.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Triangle3Df.Normal">
			<summary>Normal vector of the triangle. Note: The normal vector is not always normalized.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Triangle3Df.Plane">
			<summary>Plane of the triangle.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.Set(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Sets the triangle's points.</summary>
			<param name="point1">Point A.</param>
			<param name="point2">Point B.</param>
			<param name="point3">Point C.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.#ctor">
			<summary>Constructor for an all 0 triangle.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Triangle3Df.#ctor(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Constructor for triangle with given three points.</summary>
			<param name="point1">Point A.</param>
			<param name="point2">Point B.</param>
			<param name="point3">Point C.</param>
		</member>
		<member name="T:IrrlichtLime.Core.Vector2Df">
			<summary>2d vector class with lots of operators and methods.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Df.Angle">
			<summary>Value between 0 and 360. The angle of this vector in degrees in the counter trigonometric sense. 0 is to the right (3 o'clock), values increase clockwise.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Df.AngleTrig">
			<summary>Value between 0 and 360. The angle of this vector in degrees in the trigonometric sense. 0 is to the right (3 o'clock), values increase counter-clockwise. This method has been suggested by Pr3t3nd3r.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.DotProduct(IrrlichtLime.Core.Vector2Df)">
			<summary>Get the dot product of this vector with another.</summary>
			<param name="other">Other vector to take dot product with.</param>
			<returns>The dot product of the two vectors.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.EqualsTo(IrrlichtLime.Core.Vector2Df)">
			<summary>Checks if this vector equals the other one.

Takes floating point rounding errors into account.</summary>
			<param name="other">Vector to compare with.</param>
			<returns>True if the two vector are (almost) equal, else false.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.GetAngleWith(IrrlichtLime.Core.Vector2Df)">
			<summary>Calculates the angle between this vector and another one in degree.</summary>
			<param name="other">Other vector to test with.</param>
			<returns>Returns a value between 0 and 90.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.GetDistanceFrom(IrrlichtLime.Core.Vector2Df)">
			<summary>Gets distance from another point.

Here, the vector is interpreted as a point in 2-dimensional space.</summary>
			<param name="other">Other vector to measure from.</param>
			<returns>Distance from other point.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.GetDistanceFromSQ(IrrlichtLime.Core.Vector2Df)">
			<summary>Returns squared distance from another point.

Here, the vector is interpreted as a point in 2-dimensional space.</summary>
			<param name="other">Other vector to measure from.</param>
			<returns>Squared distance from other point.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.GetInterpolated(IrrlichtLime.Core.Vector2Df,System.Double)">
			<summary>Creates an interpolated vector between this vector and another vector.</summary>
			<param name="other">The other vector to interpolate with.</param>
			<param name="d">Interpolation value between 0.0f (all the other vector) and 1.0f (all this vector). Note that this is the opposite direction of interpolation to GetInterpolatedQuadratic().</param>
			<returns>An interpolated vector. This vector is not modified.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.GetInterpolatedQuadratic(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df,System.Double)">
			<summary>Creates a quadratically interpolated vector between this and two other vectors.</summary>
			<param name="other1">Second vector to interpolate with.</param>
			<param name="other2">Third vector to interpolate with (maximum at 1.0f)</param>
			<param name="d">Interpolation value between 0.0f (all this vector) and 1.0f (all the 3rd vector). Note that this is the opposite direction of interpolation to GetInterpolated() and Interpolate().</param>
			<returns>An interpolated vector. This vector is not modified.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.Interpolate(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df,System.Double)">
			<summary>Sets this vector to the linearly interpolated vector between two other vectors.</summary>
			<param name="other1">First vector to interpolate with, maximum at 1.0f.</param>
			<param name="other2">Second vector to interpolate with, maximum at 0.0f.</param>
			<param name="d">Interpolation value between 0.0f (all vector b) and 1.0f (all vector a). Note that this is the opposite direction of interpolation to GetInterpolatedQuadratic().</param>
			<returns>Reference to this vector, after interpolation.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.IsBetweenPoints(IrrlichtLime.Core.Vector2Df,IrrlichtLime.Core.Vector2Df)">
			<summary>Returns if this vector interpreted as a point is on a line between two other points.

It is assumed that the point is on the line.</summary>
			<param name="begin">Beginning vector to compare between.</param>
			<param name="end">Ending vector to compare between.</param>
			<returns>True if this vector is between begin and end, false if not.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Df.Length">
			<summary>Length of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Df.LengthSQ">
			<summary>The squared length of the vector.

This is useful because it is faster than: Length x Length.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.Normalize">
			<summary>Normalizes the vector.

The null vector is left untouched.</summary>
			<returns>Reference to this vector, after normalization.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.RotateBy(System.Double)">
			<summary>Rotates the point anticlockwise around a center by an amount of degrees.</summary>
			<param name="degrees">Amount of degrees to rotate by, anticlockwise.</param>
			<returns>Reference to this vector after transformation.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.RotateBy(System.Double,IrrlichtLime.Core.Vector2Df)">
			<summary>Rotates the point anticlockwise around a center by an amount of degrees.</summary>
			<param name="degrees">Amount of degrees to rotate by, anticlockwise.</param>
			<param name="center">Rotation center. Default: (0,0,0).</param>
			<returns>Reference to this vector after transformation.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.Set(IrrlichtLime.Core.Vector2Df)">
			<summary>Set value of this vector using provided vector.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.Set(System.Single,System.Single)">
			<summary>Set value of this vector using provided coordinates.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.#ctor">
			<summary>Default constructor (null vector).</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.#ctor(System.Single)">
			<summary>Constructor with the same value for both members.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.#ctor(IrrlichtLime.Core.Vector2Df)">
			<summary>Copy constructor.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Df.#ctor(System.Single,System.Single)">
			<summary>Constructor with two different values.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Df.X">
			<summary>X coordinate of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Df.Y">
			<summary>Y coordinate of the vector.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Vector2Di">
			<summary>2d vector class with lots of operators and methods.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Di.Angle">
			<summary>Value between 0 and 360. The angle of this vector in degrees in the counter trigonometric sense. 0 is to the right (3 o'clock), values increase clockwise.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Di.AngleTrig">
			<summary>Value between 0 and 360. The angle of this vector in degrees in the trigonometric sense. 0 is to the right (3 o'clock), values increase counter-clockwise. This method has been suggested by Pr3t3nd3r.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.DotProduct(IrrlichtLime.Core.Vector2Di)">
			<summary>Get the dot product of this vector with another.</summary>
			<param name="other">Other vector to take dot product with.</param>
			<returns>The dot product of the two vectors.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.EqualsTo(IrrlichtLime.Core.Vector2Di)">
			<summary>Checks if this vector equals the other one.

Takes floating point rounding errors into account.</summary>
			<param name="other">Vector to compare with.</param>
			<returns>True if the two vector are (almost) equal, else false.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.GetAngleWith(IrrlichtLime.Core.Vector2Di)">
			<summary>Calculates the angle between this vector and another one in degree.</summary>
			<param name="other">Other vector to test with.</param>
			<returns>Returns a value between 0 and 90.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.GetDistanceFrom(IrrlichtLime.Core.Vector2Di)">
			<summary>Gets distance from another point.

Here, the vector is interpreted as a point in 2-dimensional space.</summary>
			<param name="other">Other vector to measure from.</param>
			<returns>Distance from other point.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.GetDistanceFromSQ(IrrlichtLime.Core.Vector2Di)">
			<summary>Returns squared distance from another point.

Here, the vector is interpreted as a point in 2-dimensional space.</summary>
			<param name="other">Other vector to measure from.</param>
			<returns>Squared distance from other point.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.GetInterpolated(IrrlichtLime.Core.Vector2Di,System.Double)">
			<summary>Creates an interpolated vector between this vector and another vector.</summary>
			<param name="other">The other vector to interpolate with.</param>
			<param name="d">Interpolation value between 0.0f (all the other vector) and 1.0f (all this vector). Note that this is the opposite direction of interpolation to GetInterpolatedQuadratic().</param>
			<returns>An interpolated vector. This vector is not modified.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.GetInterpolatedQuadratic(IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Vector2Di,System.Double)">
			<summary>Creates a quadratically interpolated vector between this and two other vectors.</summary>
			<param name="other1">Second vector to interpolate with.</param>
			<param name="other2">Third vector to interpolate with (maximum at 1.0f)</param>
			<param name="d">Interpolation value between 0.0f (all this vector) and 1.0f (all the 3rd vector). Note that this is the opposite direction of interpolation to GetInterpolated() and Interpolate().</param>
			<returns>An interpolated vector. This vector is not modified.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.Interpolate(IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Vector2Di,System.Double)">
			<summary>Sets this vector to the linearly interpolated vector between two other vectors.</summary>
			<param name="other1">First vector to interpolate with, maximum at 1.0f.</param>
			<param name="other2">Second vector to interpolate with, maximum at 0.0f.</param>
			<param name="d">Interpolation value between 0.0f (all vector b) and 1.0f (all vector a). Note that this is the opposite direction of interpolation to GetInterpolatedQuadratic().</param>
			<returns>Reference to this vector, after interpolation.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.IsBetweenPoints(IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Vector2Di)">
			<summary>Returns if this vector interpreted as a point is on a line between two other points.

It is assumed that the point is on the line.</summary>
			<param name="begin">Beginning vector to compare between.</param>
			<param name="end">Ending vector to compare between.</param>
			<returns>True if this vector is between begin and end, false if not.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Di.Length">
			<summary>Length of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Di.LengthSQ">
			<summary>The squared length of the vector.

This is useful because it is faster than: Length x Length.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.Normalize">
			<summary>Normalizes the vector.

The null vector is left untouched.</summary>
			<returns>Reference to this vector, after normalization.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.RotateBy(System.Double)">
			<summary>Rotates the point anticlockwise around a center by an amount of degrees.</summary>
			<param name="degrees">Amount of degrees to rotate by, anticlockwise.</param>
			<returns>Reference to this vector after transformation.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.RotateBy(System.Double,IrrlichtLime.Core.Vector2Di)">
			<summary>Rotates the point anticlockwise around a center by an amount of degrees.</summary>
			<param name="degrees">Amount of degrees to rotate by, anticlockwise.</param>
			<param name="center">Rotation center. Default: (0,0,0).</param>
			<returns>Reference to this vector after transformation.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.Set(IrrlichtLime.Core.Vector2Di)">
			<summary>Set value of this vector using provided vector.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.Set(System.Int32,System.Int32)">
			<summary>Set value of this vector using provided coordinates.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.#ctor">
			<summary>Default constructor (null vector).</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.#ctor(System.Int32)">
			<summary>Constructor with the same value for both members.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.#ctor(IrrlichtLime.Core.Vector2Di)">
			<summary>Copy constructor.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector2Di.#ctor(System.Int32,System.Int32)">
			<summary>Constructor with two different values.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Di.X">
			<summary>X coordinate of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector2Di.Y">
			<summary>Y coordinate of the vector.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Vector3Df">
			<summary>3d vector class with lots of operators and methods.

The Vector3d class is used in Irrlicht for three main purposes: 1) As a direction vector (most of the methods assume this). 2) As a position in 3d space (which is synonymous with a direction vector from the origin to this position). 3) To hold three Euler rotations, where X is pitch, Y is yaw and Z is roll.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.CrossProduct(IrrlichtLime.Core.Vector3Df)">
			<summary>Calculates the cross product with another vector.</summary>
			<param name="other">Vector to multiply with.</param>
			<returns>Cross product of this vector with other.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.DotProduct(IrrlichtLime.Core.Vector3Df)">
			<summary>Get the dot product with another vector.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.EqualsTo(IrrlichtLime.Core.Vector3Df)">
			<summary>Checks if this vector equals the other one, taking floating point rounding errors into account.</summary>
			<param name="other">Other vector for comparision.</param>
			<returns>True if vectors are equals.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.EqualsTo(IrrlichtLime.Core.Vector3Df,System.Single)">
			<summary>Checks if this vector equals the other one, taking floating point rounding errors into account.</summary>
			<param name="other">Other vector for comparision.</param>
			<param name="tolerance">Tolerance of comparision. Default: 0.000001f.</param>
			<returns>True if vectors are equals.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.GetDistanceFrom(IrrlichtLime.Core.Vector3Df)">
			<summary>Get distance from another point.

Here, the vector is interpreted as point in 3 dimensional space.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.GetDistanceFromSQ(IrrlichtLime.Core.Vector3Df)">
			<summary>Returns squared distance from another point.

Here, the vector is interpreted as point in 3 dimensional space.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.GetInterpolated(IrrlichtLime.Core.Vector3Df,System.Double)">
			<summary>Creates an interpolated vector between this vector and another vector.</summary>
			<param name="other">The other vector to interpolate with.</param>
			<param name="d">Interpolation value between 0.0f (all the other vector) and 1.0f (all this vector). Note that this is the opposite direction of interpolation to GetInterpolatedQuadratic().</param>
			<returns>An interpolated vector. This vector is not modified.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.GetInterpolatedQuadratic(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,System.Double)">
			<summary>Creates a quadratically interpolated vector between this and two other vectors.</summary>
			<param name="other1">Second vector to interpolate with.</param>
			<param name="other2">Third vector to interpolate with (maximum at 1.0f)</param>
			<param name="d">Interpolation value between 0.0f (all this vector) and 1.0f (all the 3rd vector). Note that this is the opposite direction of interpolation to GetInterpolated() and Interpolate().</param>
			<returns>An interpolated vector. This vector is not modified.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Df.HorizontalAngle">
			<summary>The rotations that would make a (0,0,1) direction vector point in the same direction as this direction vector.

This property contains a rotation vector containing the X (pitch) and Y (raw) rotations (in degrees) that when applied to a +Z (e.g. 0, 0, 1) direction vector would make it point in the same direction as this vector. The Z (roll) rotation is always 0, since two Euler rotations are sufficient to point in any given direction.

Thanks to Arras on the Irrlicht forums for this method.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.Interpolate(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df,System.Double)">
			<summary>Sets this vector to the linearly interpolated vector between two other.</summary>
			<param name="other1">First vector to interpolate with, maximum at 1.0f.</param>
			<param name="other2">Second vector to interpolate with, maximum at 0.0f.</param>
			<param name="d">Interpolation value between 0.0f (all vector other2) and 1.0f (all vector other1). Note that this is the opposite direction of interpolation to GetInterpolatedQuadratic().</param>
			<returns>Reference to this vector after interpolation.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.Invert">
			<summary>Inverts the vector.</summary>
			<returns>Reference to this vector after inversion.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.IsBetweenPoints(IrrlichtLime.Core.Vector3Df,IrrlichtLime.Core.Vector3Df)">
			<summary>Checks if this vector interpreted as a point is on a line between two other points.

It is assumed that the point is on the line.</summary>
			<param name="begin">Beginning vector to compare between.</param>
			<param name="end">Ending vector to compare between.</param>
			<returns>True if this vector is between begin and end, false if not.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Df.Length">
			<summary>Length of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Df.LengthSQ">
			<summary>The squared length of the vector.

This is useful because it is faster than: Length x Length.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.Normalize">
			<summary>Normalizes the vector.

In case of the 0 vector the result is still 0, otherwise the length of the vector will be 1.</summary>
			<returns>Reference to this vector after normalization.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.RotateXYby(System.Double)">
			<summary>Rotates the vector by a specified number of degrees around the Z axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the Z axis.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.RotateXYby(System.Double,IrrlichtLime.Core.Vector3Df)">
			<summary>Rotates the vector by a specified number of degrees around the Z axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the Z axis.</param>
			<param name="center">The center of the rotation.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.RotateXZby(System.Double)">
			<summary>Rotates the vector by a specified number of degrees around the Y axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the Y axis.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.RotateXZby(System.Double,IrrlichtLime.Core.Vector3Df)">
			<summary>Rotates the vector by a specified number of degrees around the Y axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the Y axis.</param>
			<param name="center">The center of the rotation.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.RotateYZby(System.Double)">
			<summary>Rotates the vector by a specified number of degrees around the X axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the X axis.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.RotateYZby(System.Double,IrrlichtLime.Core.Vector3Df)">
			<summary>Rotates the vector by a specified number of degrees around the X axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the X axis.</param>
			<param name="center">The center of the rotation.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.RotationToDirection">
			<summary>Builds a direction vector from (this) rotation vector.

This vector is assumed to be a rotation vector composed of 3 Euler angle rotations, in degrees. The implementation performs the same calculations as using a matrix to do the rotation.</summary>
			<returns>A direction vector calculated by rotating the forwards direction by the 3 Euler angles (in degrees) represented by this vector.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.RotationToDirection(IrrlichtLime.Core.Vector3Df)">
			<summary>Builds a direction vector from (this) rotation vector.

This vector is assumed to be a rotation vector composed of 3 Euler angle rotations, in degrees. The implementation performs the same calculations as using a matrix to do the rotation.</summary>
			<param name="forwards">The direction representing "forwards" which will be rotated by this vector. If you do not provide a direction, then the +Z axis (0, 0, 1) will be assumed to be forwards.</param>
			<returns>A direction vector calculated by rotating the forwards direction by the 3 Euler angles (in degrees) represented by this vector.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.Set(IrrlichtLime.Core.Vector3Df)">
			<summary>Sets new value of this vector.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.Set(System.Single,System.Single,System.Single)">
			<summary>Sets new value of this vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Df.SphericalCoordinateAngles">
			<summary>The spherical coordinate angles.

This returns Euler degrees for the point represented by this vector. The calculation assumes the pole at (0,1,0) and returns the angles in X and Y.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.ToArray">
			<summary>Fills an array of 4 values with the vector data.

Useful for setting in shader constants for example. The fourth value will always be 0.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.#ctor">
			<summary>Default constructor (null vector).</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.#ctor(System.Single)">
			<summary>Constructor with the same value for all three elements.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.#ctor(IrrlichtLime.Core.Vector3Df)">
			<summary>Copy constructor.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Df.#ctor(System.Single,System.Single,System.Single)">
			<summary>Constructor with three different values.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Df.X">
			<summary>X coordinate of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Df.Y">
			<summary>Y coordinate of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Df.Z">
			<summary>Z coordinate of the vector.</summary>
		</member>
		<member name="T:IrrlichtLime.Core.Vector3Di">
			<summary>3d vector class with lots of operators and methods.

The Vector3D class is used in Irrlicht for three main purposes: 1) As a direction vector (most of the methods assume this). 2) As a position in 3d space (which is synonymous with a direction vector from the origin to this position). 3) To hold three Euler rotations, where X is pitch, Y is yaw and Z is roll.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.CrossProduct(IrrlichtLime.Core.Vector3Di)">
			<summary>Calculates the cross product with another vector.</summary>
			<param name="other">Vector to multiply with.</param>
			<returns>Cross product of this vector with other.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.DotProduct(IrrlichtLime.Core.Vector3Di)">
			<summary>Get the dot product with another vector.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.EqualsTo(IrrlichtLime.Core.Vector3Di)">
			<summary>Checks if this vector equals the other one, taking floating point rounding errors into account.</summary>
			<param name="other">Other vector for comparision.</param>
			<returns>True if vectors are equals.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.EqualsTo(IrrlichtLime.Core.Vector3Di,System.Int32)">
			<summary>Checks if this vector equals the other one, taking floating point rounding errors into account.</summary>
			<param name="other">Other vector for comparision.</param>
			<param name="tolerance">Tolerance of comparision. Default: 0.000001f. NOTE: this argument is integer, so for integer version of Vector3D there is no sense to use this method with tolerance argument. DO NOT USE THIS OVERLOADING, USE only EqualsTo(other) INSTEAD.</param>
			<returns>True if vectors are equals.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.GetDistanceFrom(IrrlichtLime.Core.Vector3Di)">
			<summary>Get distance from another point.

Here, the vector is interpreted as point in 3 dimensional space.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.GetDistanceFromSQ(IrrlichtLime.Core.Vector3Di)">
			<summary>Returns squared distance from another point.

Here, the vector is interpreted as point in 3 dimensional space.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.GetInterpolated(IrrlichtLime.Core.Vector3Di,System.Double)">
			<summary>Creates an interpolated vector between this vector and another vector.</summary>
			<param name="other">The other vector to interpolate with.</param>
			<param name="d">Interpolation value between 0.0f (all the other vector) and 1.0f (all this vector). Note that this is the opposite direction of interpolation to GetInterpolatedQuadratic().</param>
			<returns>An interpolated vector. This vector is not modified.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.GetInterpolatedQuadratic(IrrlichtLime.Core.Vector3Di,IrrlichtLime.Core.Vector3Di,System.Double)">
			<summary>Creates a quadratically interpolated vector between this and two other vectors.</summary>
			<param name="other1">Second vector to interpolate with.</param>
			<param name="other2">Third vector to interpolate with (maximum at 1.0f)</param>
			<param name="d">Interpolation value between 0.0f (all this vector) and 1.0f (all the 3rd vector). Note that this is the opposite direction of interpolation to GetInterpolated() and Interpolate().</param>
			<returns>An interpolated vector. This vector is not modified.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Di.HorizontalAngle">
			<summary>The rotations that would make a (0,0,1) direction vector point in the same direction as this direction vector.

This property contains a rotation vector containing the X (pitch) and Y (raw) rotations (in degrees) that when applied to a +Z (e.g. 0, 0, 1) direction vector would make it point in the same direction as this vector. The Z (roll) rotation is always 0, since two Euler rotations are sufficient to point in any given direction.

Thanks to Arras on the Irrlicht forums for this method.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.Interpolate(IrrlichtLime.Core.Vector3Di,IrrlichtLime.Core.Vector3Di,System.Double)">
			<summary>Sets this vector to the linearly interpolated vector between two other.</summary>
			<param name="other1">First vector to interpolate with, maximum at 1.0f.</param>
			<param name="other2">Second vector to interpolate with, maximum at 0.0f.</param>
			<param name="d">Interpolation value between 0.0f (all vector other2) and 1.0f (all vector other1). Note that this is the opposite direction of interpolation to GetInterpolatedQuadratic().</param>
			<returns>Reference to this vector after interpolation.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.Invert">
			<summary>Inverts the vector.</summary>
			<returns>Reference to this vector after inversion.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.IsBetweenPoints(IrrlichtLime.Core.Vector3Di,IrrlichtLime.Core.Vector3Di)">
			<summary>Checks if this vector interpreted as a point is on a line between two other points.

It is assumed that the point is on the line.</summary>
			<param name="begin">Beginning vector to compare between.</param>
			<param name="end">Ending vector to compare between.</param>
			<returns>True if this vector is between begin and end, false if not.</returns>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Di.Length">
			<summary>Length of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Di.LengthSQ">
			<summary>The squared length of the vector.

This is useful because it is faster than: Length x Length.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.Normalize">
			<summary>Normalizes the vector.

In case of the 0 vector the result is still 0, otherwise the length of the vector will be 1.</summary>
			<returns>Reference to this vector after normalization.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.RotateXYby(System.Double)">
			<summary>Rotates the vector by a specified number of degrees around the Z axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the Z axis.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.RotateXYby(System.Double,IrrlichtLime.Core.Vector3Di)">
			<summary>Rotates the vector by a specified number of degrees around the Z axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the Z axis.</param>
			<param name="center">The center of the rotation.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.RotateXZby(System.Double)">
			<summary>Rotates the vector by a specified number of degrees around the Y axis and the specified center.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.RotateXZby(System.Double,IrrlichtLime.Core.Vector3Di)">
			<summary>Rotates the vector by a specified number of degrees around the Y axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the Y axis.</param>
			<param name="center">The center of the rotation.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.RotateYZby(System.Double)">
			<summary>Rotates the vector by a specified number of degrees around the X axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the X axis.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.RotateYZby(System.Double,IrrlichtLime.Core.Vector3Di)">
			<summary>Rotates the vector by a specified number of degrees around the X axis and the specified center.</summary>
			<param name="degrees">Number of degrees to rotate around the X axis.</param>
			<param name="center">The center of the rotation.</param>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.RotationToDirection">
			<summary>Builds a direction vector from (this) rotation vector.

This vector is assumed to be a rotation vector composed of 3 Euler angle rotations, in degrees. The implementation performs the same calculations as using a matrix to do the rotation.</summary>
			<returns>A direction vector calculated by rotating the forwards direction by the 3 Euler angles (in degrees) represented by this vector.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.RotationToDirection(IrrlichtLime.Core.Vector3Di)">
			<summary>Builds a direction vector from (this) rotation vector.

This vector is assumed to be a rotation vector composed of 3 Euler angle rotations, in degrees. The implementation performs the same calculations as using a matrix to do the rotation.</summary>
			<param name="forwards">The direction representing "forwards" which will be rotated by this vector. If you do not provide a direction, then the +Z axis (0, 0, 1) will be assumed to be forwards.</param>
			<returns>A direction vector calculated by rotating the forwards direction by the 3 Euler angles (in degrees) represented by this vector.</returns>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.Set(IrrlichtLime.Core.Vector3Di)">
			<summary>Sets new value of this vector.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.Set(System.Int32,System.Int32,System.Int32)">
			<summary>Sets new value of this vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Di.SphericalCoordinateAngles">
			<summary>The spherical coordinate angles.

This returns Euler degrees for the point represented by this vector. The calculation assumes the pole at (0,1,0) and returns the angles in X and Y.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.ToArray">
			<summary>Fills an array of 4 values with the vector data.

Useful for setting in shader constants for example. The fourth value will always be 0.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.#ctor">
			<summary>Default constructor (null vector).</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.#ctor(System.Int32)">
			<summary>Constructor with the same value for all three elements.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.#ctor(IrrlichtLime.Core.Vector3Di)">
			<summary>Copy constructor.</summary>
		</member>
		<member name="M:IrrlichtLime.Core.Vector3Di.#ctor(System.Int32,System.Int32,System.Int32)">
			<summary>Constructor with three different values.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Di.X">
			<summary>X coordinate of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Di.Y">
			<summary>Y coordinate of the vector.</summary>
		</member>
		<member name="P:IrrlichtLime.Core.Vector3Di.Z">
			<summary>Z coordinate of the vector.</summary>
		</member>
		<member name="T:IrrlichtLime.IO.AttributeExchangingObject">
			<summary>An object which is able to serialize and deserialize its attributes into an attributes object.</summary>
		</member>
		<member name="T:IrrlichtLime.IO.FileArchive">
			<summary>The FileArchive manages archives and provides access to files inside them.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.FileArchive.CreateAndOpenFile(System.String)">
			<summary>Opens a file based on its name.</summary>
			<param name="filename">The file to open.</param>
			<returns>Returns A pointer to the created file on success, or null on failure.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileArchive.CreateAndOpenFile(System.Int32)">
			<summary>Opens a file based on its position in the file list.</summary>
			<param name="index">The zero based index of the file.</param>
			<returns>Returns a pointer to the created file on success, or null on failure.</returns>
		</member>
		<member name="P:IrrlichtLime.IO.FileArchive.FileList">
			<summary>The complete directory tree for the archive, including all files and folders.</summary>
		</member>
		<member name="P:IrrlichtLime.IO.FileArchive.Password">
			<summary>An optionally used password string.</summary>
		</member>
		<member name="P:IrrlichtLime.IO.FileArchive.Type">
			<summary>The archive type.</summary>
		</member>
		<member name="T:IrrlichtLime.IO.FileArchiveType">
			<summary>The different types of archives.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileArchiveType.Folder">
			<summary>A virtual directory.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileArchiveType.GZIP">
			<summary>A GZIP archive.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileArchiveType.NPK">
			<summary>A Nebula Device archive.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileArchiveType.PAK">
			<summary>An ID Software PAK archive.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileArchiveType.TAR">
			<summary>A Tape ARchive.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileArchiveType.Unknown">
			<summary>The type of this archive is unknown.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileArchiveType.WAD">
			<summary>A WAD archive, Quake2, Halflife.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileArchiveType.ZIP">
			<summary>A PKZIP archive.</summary>
		</member>
		<member name="T:IrrlichtLime.IO.FileList">
			<summary>Provides a list of files and folders.

File lists usually contain a list of all files in a given folder, but can also contain a complete directory structure.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.AddFile(System.String,System.Int32,System.Int32,System.Boolean)">
			<summary>Add as a file or folder to the list.</summary>
			<param name="fullPath">The file name including path, from the root of the file list.</param>
			<param name="offset">The file offset inside an archive.</param>
			<param name="size">The size of the file in bytes.</param>
			<param name="isDirectory">True if this is a directory rather than a file.</param>
			<returns>Returns index of added file in this FileList.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.AddFile(System.String,System.Int32,System.Int32,System.Boolean,System.Int32)">
			<summary>Add as a file or folder to the list.</summary>
			<param name="fullPath">The file name including path, from the root of the file list.</param>
			<param name="offset">The file offset inside an archive.</param>
			<param name="size">The size of the file in bytes.</param>
			<param name="isDirectory">True if this is a directory rather than a file.</param>
			<param name="id">The ID of the file in the archive which owns it. Default: 0.</param>
			<returns>Returns index of added file in this FileList.</returns>
		</member>
		<member name="P:IrrlichtLime.IO.FileList.Count">
			<summary>Amount of files and directories in the file list.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.FindFile(System.String)">
			<summary>Searches for a file or folder in the list.</summary>
			<param name="filename">The name of the file to search for.</param>
			<returns>Returns the index of the file in this FileList, or -1 if no matching name name was found.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.FindFile(System.String,System.Boolean)">
			<summary>Searches for a file or folder in the list.</summary>
			<param name="filename">The name of the file to search for.</param>
			<param name="isDirectory">True if you are searching for a directory, false if you want a file. Default: false.</param>
			<returns>Returns the index of the file in this FileList, or -1 if no matching name name was found.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.GetFileID(System.Int32)">
			<summary>Returns the ID of a file in the file list, based on an index.</summary>
			<param name="index">The zero based index of the file.</param>
			<returns>ID of the file.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.GetFileName(System.Int32)">
			<summary>Gets the name of a file in the list, based on an index.

The path is not included in this name. Use GetFullFileName() for this.</summary>
			<param name="index">The zero based index of the file.</param>
			<returns>File name of the file. Returns null, if an error occured.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.GetFileOffset(System.Int32)">
			<summary>Returns the file offset of a file in the file list, based on an index.</summary>
			<param name="index">The zero based index of the file.</param>
			<returns>The offset of the file.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.GetFileSize(System.Int32)">
			<summary>Returns the size of a file in the file list, based on an index.</summary>
			<param name="index">The zero based index of the file.</param>
			<returns>The size of the file in bytes.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.GetFullFileName(System.Int32)">
			<summary>Gets the full name of a file in the list including the path, based on an index.</summary>
			<param name="index">The zero based index of the file.</param>
			<returns>Full file name of the file. Returns null if an error occured.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.IsDirectory(System.Int32)">
			<summary>Checks if the file is a directory.</summary>
			<param name="index">The zero based index of the file.</param>
			<returns>True if the file is a directory, else false.</returns>
		</member>
		<member name="P:IrrlichtLime.IO.FileList.Path">
			<summary>The base path of the file list.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.FileList.Sort">
			<summary>Sorts the file list. You should call this after adding any items to the file list.</summary>
		</member>
		<member name="T:IrrlichtLime.IO.FileSystem">
			<summary>Manages files and archives and provides access to them.

This class manages where files are, so that modules which use the the IO do not need to know where every file is located. A file could be in a ZIP archive or as file on disk, using the FileSystem makes no difference to this.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.AddFileArchive(System.String)">
			<summary>Adds an archive to the file system.

After calling this, the Irrlicht Engine will also search and open files directly from this archive. This is useful for hiding data from the end user, speeding up file access and making it possible to access for example Quake3 .pk3 files, which are just renamed .zip files. Irrlicht supports AES-encrypted zip files, and the advanced compression techniques lzma and bzip2.</summary>
			<param name="filename">Filename of the archive to add to the file system.</param>
			<returns>True if the archive was added successfully, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.AddFileArchive(System.String,System.Boolean)">
			<summary>Adds an archive to the file system.

After calling this, the Irrlicht Engine will also search and open files directly from this archive. This is useful for hiding data from the end user, speeding up file access and making it possible to access for example Quake3 .pk3 files, which are just renamed .zip files. Irrlicht supports AES-encrypted zip files, and the advanced compression techniques lzma and bzip2.</summary>
			<param name="filename">Filename of the archive to add to the file system.</param>
			<param name="ignoreCase">If set to true, files in the archive can be accessed without writing all letters in the right case. Default: true.</param>
			<returns>True if the archive was added successfully, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.AddFileArchive(System.String,System.Boolean,System.Boolean)">
			<summary>Adds an archive to the file system.

After calling this, the Irrlicht Engine will also search and open files directly from this archive. This is useful for hiding data from the end user, speeding up file access and making it possible to access for example Quake3 .pk3 files, which are just renamed .zip files. Irrlicht supports AES-encrypted zip files, and the advanced compression techniques lzma and bzip2.</summary>
			<param name="filename">Filename of the archive to add to the file system.</param>
			<param name="ignoreCase">If set to true, files in the archive can be accessed without writing all letters in the right case. Default: true.</param>
			<param name="ignorePaths">If set to true, files in the added archive can be accessed without its complete path. Default: true.</param>
			<returns>True if the archive was added successfully, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.AddFileArchive(System.String,System.Boolean,System.Boolean,IrrlichtLime.IO.FileArchiveType)">
			<summary>Adds an archive to the file system.

After calling this, the Irrlicht Engine will also search and open files directly from this archive. This is useful for hiding data from the end user, speeding up file access and making it possible to access for example Quake3 .pk3 files, which are just renamed .zip files. Irrlicht supports AES-encrypted zip files, and the advanced compression techniques lzma and bzip2.</summary>
			<param name="filename">Filename of the archive to add to the file system.</param>
			<param name="ignoreCase">If set to true, files in the archive can be accessed without writing all letters in the right case. Default: true.</param>
			<param name="ignorePaths">If set to true, files in the added archive can be accessed without its complete path. Default: true.</param>
			<param name="archiveType">If no specific FileArchiveType is selected then the type of archive will depend on the extension of the file name. If you use a different extension then you can use this parameter to force a specific type of archive. Default: FileArchiveType.Unknown.</param>
			<returns>True if the archive was added successfully, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.AddFileArchive(System.String,System.Boolean,System.Boolean,IrrlichtLime.IO.FileArchiveType,System.String)">
			<summary>Adds an archive to the file system.

After calling this, the Irrlicht Engine will also search and open files directly from this archive. This is useful for hiding data from the end user, speeding up file access and making it possible to access for example Quake3 .pk3 files, which are just renamed .zip files. Irrlicht supports AES-encrypted zip files, and the advanced compression techniques lzma and bzip2.</summary>
			<param name="filename">Filename of the archive to add to the file system.</param>
			<param name="ignoreCase">If set to true, files in the archive can be accessed without writing all letters in the right case. Default: true.</param>
			<param name="ignorePaths">If set to true, files in the added archive can be accessed without its complete path. Default: true.</param>
			<param name="archiveType">If no specific FileArchiveType is selected then the type of archive will depend on the extension of the file name. If you use a different extension then you can use this parameter to force a specific type of archive. Default: FileArchiveType.Unknown.</param>
			<param name="password">An optional password, which is used in case of encrypted archives. Default: emptry string (which means - no password).</param>
			<returns>True if the archive was added successfully, false if not.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.CreateEmptyFileList(System.String,System.Boolean,System.Boolean)">
			<summary>Creates an empty filelist.</summary>
			<param name="path">Virtual path to use.</param>
			<param name="ignoreCase">If set to true, files in the archive can be accessed without writing all letters in the right case.</param>
			<param name="ignorePaths">If set to true, files in the added archive can be accessed without its complete path.</param>
			<returns>Created FileList is returned. After the list has been used it has to be deleted using Drop() method.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.CreateFileList">
			<summary>Creates a list of files and directories in the current working directory and returns it.</summary>
			<returns>Created FileList is returned. After the list has been used it has to be deleted using Drop() method.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.CreateLimitReadFile(System.String,IrrlichtLime.IO.ReadFile,System.Int32,System.Int32)">
			<summary>Creates a ReadFile object for accessing data inside a file.

This is useful  for archives.</summary>
			<param name="filename">The name given to this file.</param>
			<param name="alreadyOpenedFile">Already opened file.</param>
			<param name="areaPosition">Start of the file inside alreadyOpenedFile.</param>
			<param name="areaSize">The length of the file to open.</param>
			<returns>Created ReadFile object. The returned pointer should be dropped using Drop() method when no longer needed.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.CreateMemoryReadFile(System.String,System.Byte[])">
			<summary>Creates a ReadFile object for accessing memory like a file.

This allows you to use a memory where a ReadFile is requested.</summary>
			<param name="filename">The name given to this file.</param>
			<param name="content">Content of the file.</param>
			<returns>Created ReadFile object. The returned pointer should be dropped using Drop() method when no longer needed.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.CreateMemoryWriteFile(System.String,System.Int32)">
			<summary>Creates a WriteFile object for accessing memory like a file.

This allows you to use a memory where a WriteFile is requested. You are responsible for specifing big enought length parameter.</summary>
			<param name="filename">The name given to this file.</param>
			<param name="length">Length of the file.</param>
			<returns>Created WriteFile object. The returned pointer should be dropped using Drop() method when no longer needed.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.CreateReadFile(System.String)">
			<summary>Opens a file for read access.</summary>
			<param name="filename">Name of file to open.</param>
			<returns>Created ReadFile object. The returned pointer should be dropped using Drop() method when no longer needed.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.CreateWriteFile(System.String)">
			<summary>Opens a file for write access.</summary>
			<param name="filename">Name of file to open.</param>
			<returns>Created WriteFile object. The returned pointer should be dropped using Drop() method when no longer needed.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.CreateWriteFile(System.String,System.Boolean)">
			<summary>Opens a file for write access.</summary>
			<param name="filename">Name of file to open.</param>
			<param name="append">If the file already exist, all write operations are appended to the file. Default: false.</param>
			<returns>Created WriteFile object. The returned pointer should be dropped using Drop() method when no longer needed.</returns>
		</member>
		<member name="P:IrrlichtLime.IO.FileSystem.FileArchiveCount">
			<summary>The number of archives currently attached to the file system.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.GetFileAbsolutePath(System.String)">
			<summary>Converts a relative path to an absolute (unique) path, resolving symbolic links if required.</summary>
			<param name="filename">Possibly relative file or directory name to query.</param>
			<returns>Absolute filename which points to the same file.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.GetFileArchive(System.Int32)">
			<summary>Get the archive at a given index.</summary>
			<param name="index">Index of the archive.</param>
			<returns>Returns FileArchive object.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.GetFileBasename(System.String)">
			<summary>Get the base part of a filename, i.e. the name without the directory part. If no directory is prefixed, the full name is returned.</summary>
			<param name="filename">The file to get the basename from.</param>
			<returns>Base part of a filename.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.GetFileBasename(System.String,System.Boolean)">
			<summary>Get the base part of a filename, i.e. the name without the directory part. If no directory is prefixed, the full name is returned.</summary>
			<param name="filename">The file to get the basename from.</param>
			<param name="keepExtension">True if filename with extension is returned otherwise everything after the final '.' is removed as well. Default: true.</param>
			<returns>Base part of a filename.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.GetFileDirectory(System.String)">
			<summary>Get the directory a file is located in.</summary>
			<param name="filename">The file to get the directory from.</param>
			<returns>String containing the directory of the file.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.MoveFileArchive(System.Int32,System.Int32)">
			<summary>Changes the search order of attached archives.</summary>
			<param name="index">The index of the archive to change.</param>
			<param name="relative">The relative change in position, archives with a lower index are searched first.</param>
			<returns>True if move operation is made.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.RemoveFileArchive(System.String)">
			<summary>Removes an archive from the file system.

This will close the archive and free any file handles, but will not close resources which have already been loaded and are now cached, for example textures and meshes.</summary>
			<param name="filename">The archive of the given name will be removed.</param>
			<returns>True on success, false on failure.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.RemoveFileArchive(System.Int32)">
			<summary>Removes an archive from the file system.

This will close the archive and free any file handles, but will not close resources which have already been loaded and are now cached, for example textures and meshes.</summary>
			<param name="index">The index of the archive to remove.</param>
			<returns>True on success, false on failure.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.FileSystem.SetFileSystemType(IrrlichtLime.IO.FileSystemType)">
			<summary>Set the active type of file system.</summary>
			<param name="newType">New type of file system to set.</param>
			<returns>Returns previous file system type.</returns>
		</member>
		<member name="P:IrrlichtLime.IO.FileSystem.WorkingDirectory">
			<summary>Current working directory.</summary>
		</member>
		<member name="T:IrrlichtLime.IO.FileSystemType">
			<summary>File system types, which can be used for browsing.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileSystemType.Native">
			<summary>Native OS' file system.</summary>
		</member>
		<member name="F:IrrlichtLime.IO.FileSystemType.Virtual">
			<summary>Virtual file system.</summary>
		</member>
		<member name="T:IrrlichtLime.IO.NamedPath">
			<summary>Used in places where we identify objects by a filename, but don't actually work with the real filename.

Irrlicht is internally not case-sensitive when it comes to names.</summary>
		</member>
		<member name="P:IrrlichtLime.IO.NamedPath.InternalName">
			<summary>The name which is used to identify the file.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.NamedPath.#ctor">
			<summary>Empty constructor.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.NamedPath.#ctor(System.String)">
			<summary>Constructor with given file path.</summary>
			<param name="path">Path to a file (including file' name and extension).</param>
		</member>
		<member name="P:IrrlichtLime.IO.NamedPath.Path">
			<summary>Path to the file.</summary>
		</member>
		<member name="T:IrrlichtLime.IO.ReadFile">
			<summary>Provides read acess to a file.</summary>
		</member>
		<member name="P:IrrlichtLime.IO.ReadFile.FileName">
			<summary>Name of the file.</summary>
		</member>
		<member name="P:IrrlichtLime.IO.ReadFile.Position">
			<summary>Current position in the file in bytes.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.ReadFile.Read(System.Int32)">
			<summary>Reads an amount of bytes from the file.</summary>
			<param name="bytesToRead">Amount of bytes to read from the file.</param>
			<returns>Array of bytes.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.ReadFile.Seek(System.Int32)">
			<summary>Changes position in file.</summary>
			<param name="position">Destination position in the file.</param>
			<returns>True if successful, otherwise false.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.ReadFile.Seek(System.Int32,System.Boolean)">
			<summary>Changes position in file.</summary>
			<param name="position">Destination position in the file.</param>
			<param name="relativeMovement">If set to true, the position in the file is changed relative to current position. Otherwise the position is changed from beginning of file. Default: false.</param>
			<returns>True if successful, otherwise false.</returns>
		</member>
		<member name="P:IrrlichtLime.IO.ReadFile.Size">
			<summary>Size of the file in bytes.</summary>
		</member>
		<member name="T:IrrlichtLime.IO.WriteFile">
			<summary>Provides write acess to a file.</summary>
		</member>
		<member name="P:IrrlichtLime.IO.WriteFile.FileName">
			<summary>Name of the file.</summary>
		</member>
		<member name="P:IrrlichtLime.IO.WriteFile.Position">
			<summary>Current position in the file in bytes.</summary>
		</member>
		<member name="M:IrrlichtLime.IO.WriteFile.Seek(System.Int32)">
			<summary>Changes position in file.</summary>
			<param name="position">Destination position in the file.</param>
			<returns>True if successful, otherwise false.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.WriteFile.Seek(System.Int32,System.Boolean)">
			<summary>Changes position in file.</summary>
			<param name="position">Destination position in the file.</param>
			<param name="relativeMovement">If set to true, the position in the file is changed relative to current position. Otherwise the position is changed from beginning of file. Default: false.</param>
			<returns>True if successful, otherwise false.</returns>
		</member>
		<member name="M:IrrlichtLime.IO.WriteFile.Write(System.Byte[])">
			<summary>Writes an amount of bytes to the file.</summary>
			<param name="buffer">Array of bytes to write.</param>
			<returns>How much bytes actually were written.</returns>
		</member>
		<member name="M:IrrlichtLime.Scene.SceneManager.CreateFlyCircleAnimator(IrrlichtLime.Core.Vector3Df,System.Single,System.Single,IrrlichtLime.Core.Vector3Df,System.Single)">
			<param name="startPosition">0.0f ... 1.0f</param>
		</member>
		<member name="M:IrrlichtLime.Scene.SceneManager.CreateFlyCircleAnimator(IrrlichtLime.Core.Vector3Df,System.Single,System.Single,IrrlichtLime.Core.Vector3Df,System.Single,System.Single)">
			<param name="startPosition">0.0f ... 1.0f</param>
		</member>
		<member name="T:IrrlichtLime.Video.AntiAliasingMode">
			<summary>These flags are used to specify the anti-aliasing and smoothing modes.

Techniques supported are multisampling, geometry smoothing, and alpha to coverage. Some drivers don't support a per-material setting of the anti-aliasing modes. In those cases, FSAA/multisampling is defined by the device mode chosen upon creation via IrrlichtCreationParameters.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.AntiAliasingMode.AlphaToCoverage">
			<summary>Enhanced anti-aliasing for transparent materials.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.AntiAliasingMode.FullBasic">
			<summary>All typical anti-alias and smooth modes.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.AntiAliasingMode.LineSmooth">
			<summary>Line smoothing.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.AntiAliasingMode.Off">
			<summary>Use to turn off anti-aliasing for this material.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.AntiAliasingMode.PointSmooth">
			<summary>point smoothing, often in software and slow, only with OpenGL.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.AntiAliasingMode.Quality">
			<summary>High-quality anti-aliasing, not always supported, automatically enables Simple mode.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.AntiAliasingMode.Simple">
			<summary>Default anti-aliasing mode.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.Color">
			<summary>Class representing a 32 bit ARGB color.

The color values for alpha, red, green, and blue are stored in a single unsigned int. So all four values may be between 0 and 255. Alpha in Irrlicht is opacity, so 0 is fully transparent, 255 is fully opaque (solid). This class is used by most parts of the Irrlicht Engine to specify a color.

Another way is using the class Colorf, which stores the color values in 4 floats.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Color.A1R5G5B5">
			<summary>Color in A1R5G5B5 format.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Color.Alpha">
			<summary>Alpha component of the color.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Color.ARGB">
			<summary>Color in A8R8G8B8 Format.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Color.Average">
			<summary>Average intensity of the color in range [0, 255].</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Color.Blue">
			<summary>Blue component of the color.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Color.#ctor">
			<summary>Creates a color without initialization. Value of the color will be random.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Color.#ctor(System.UInt32)">
			<summary>Creates a color using ARGB value.</summary>
			<param name="argb">Value from 0 to 0xffffffff.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Color.#ctor(IrrlichtLime.Video.Color)">
			<summary>Creates a copy of color.</summary>
			<param name="copy">Color to copy.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Color.#ctor(System.Int32,System.Int32,System.Int32)">
			<summary>Creates a color using red, green, blue and alpha values.</summary>
			<param name="r">Red component. Must be value between 0 and 255.</param>
			<param name="g">Green component. Must be value between 0 and 255.</param>
			<param name="b">Blue component. Must be value between 0 and 255.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Color.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Creates a color using red, green, blue and alpha values.</summary>
			<param name="r">Red component. Must be value between 0 and 255.</param>
			<param name="g">Green component. Must be value between 0 and 255.</param>
			<param name="b">Blue component. Must be value between 0 and 255.</param>
			<param name="a">Alpha component. Must be value between 0 and 255. Default: 255 (fully opaque).</param>
		</member>
		<member name="P:IrrlichtLime.Video.Color.Green">
			<summary>Green component of the color.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Color.Lightness">
			<summary>Lightness of the color in the range [0, 255].</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Color.Luminance">
			<summary>Luminance of the color in range [0, 255].</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Color.Red">
			<summary>Red component of the color.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Color.Set(System.UInt32)">
			<summary>Sets a color value using ARGB value.</summary>
			<param name="argb">Value from 0 to 0xffffffff.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Color.Set(IrrlichtLime.Video.Color)">
			<summary>Sets value of the color to provided copy.</summary>
			<param name="copy">Color to copy.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Color.Set(System.Int32,System.Int32,System.Int32)">
			<summary>Sets a color value using red, green, blue and alpha values.</summary>
			<param name="r">Red component. Must be value between 0 and 255.</param>
			<param name="g">Green component. Must be value between 0 and 255.</param>
			<param name="b">Blue component. Must be value between 0 and 255.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Color.Set(System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Sets a color value using red, green, blue and alpha values.</summary>
			<param name="r">Red component. Must be value between 0 and 255.</param>
			<param name="g">Green component. Must be value between 0 and 255.</param>
			<param name="b">Blue component. Must be value between 0 and 255.</param>
			<param name="a">Alpha component. Must be value between 0 and 255. Default: 255 (fully opaque).</param>
		</member>
		<member name="T:IrrlichtLime.Video.Colorf">
			<summary>Class representing a 128 bit color (using 4 floats).

The color values for red, green, blue and alpha are each stored in a 32 bit floating point variable. So all four values may be between 0.0f and 1.0f. Another, faster way to define colors is using the class Color, which stores the color values in a single 32 bit integer.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Colorf.Alpha">
			<summary>Alpha component of the color.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Colorf.Blue">
			<summary>Blue component of the color.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.#ctor">
			<summary>Creates a default color. Sets red, green and blue to 0.0f and alpha to 1.0f.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.#ctor(IrrlichtLime.Video.Color)">
			<summary>Creates a copy of 32 bit color.</summary>
			<param name="copyColor">Color to copy.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.#ctor(IrrlichtLime.Video.Colorf)">
			<summary>Creates a copy of 128 bit color.</summary>
			<param name="copyColorf">Color to copy.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.#ctor(System.Single,System.Single,System.Single)">
			<summary>Creates a color using red, green, blue and alpha values.</summary>
			<param name="r">Red component. Must be value between 0.0f and 1.0f.</param>
			<param name="g">Green component. Must be value between 0.0f and 1.0f.</param>
			<param name="b">Blue component. Must be value between 0.0f and 1.0f.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.#ctor(System.Single,System.Single,System.Single,System.Single)">
			<summary>Creates a color using red, green, blue and alpha values.</summary>
			<param name="r">Red component. Must be value between 0.0f and 1.0f.</param>
			<param name="g">Green component. Must be value between 0.0f and 1.0f.</param>
			<param name="b">Blue component. Must be value between 0.0f and 1.0f.</param>
			<param name="a">Alpha component. Must be value between 0.0f and 1.0f. Default: 1.0f (fully opaque).</param>
		</member>
		<member name="P:IrrlichtLime.Video.Colorf.Green">
			<summary>Green component of the color.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Colorf.Red">
			<summary>Red component of the color.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.Set(IrrlichtLime.Video.Color)">
			<summary>Sets value of the color to provided 32 bit copy.</summary>
			<param name="copyColor">Color to copy.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.Set(IrrlichtLime.Video.Colorf)">
			<summary>Sets value of the color to provided 128 bit copy.</summary>
			<param name="copyColorf">Color to copy.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.Set(System.Single,System.Single,System.Single)">
			<summary>Sets a color value using red, green, blue and alpha values.</summary>
			<param name="r">Red component. Must be value between 0.0f and 1.0f.</param>
			<param name="g">Green component. Must be value between 0.0f and 1.0f.</param>
			<param name="b">Blue component. Must be value between 0.0f and 1.0f.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.Set(System.Single,System.Single,System.Single,System.Single)">
			<summary>Sets a color value using red, green, blue and alpha values.</summary>
			<param name="r">Red component. Must be value between 0.0f and 1.0f.</param>
			<param name="g">Green component. Must be value between 0.0f and 1.0f.</param>
			<param name="b">Blue component. Must be value between 0.0f and 1.0f.</param>
			<param name="a">Alpha component. Must be value between 0.0f and 1.0f. Default: 1.0f (fully opaque).</param>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.ToArray">
			<summary>Returns array of 4 floats, which contains red, green, blue and alpha components.</summary>
			<returns>Array of 4 floats.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.Colorf.ToColor">
			<summary>Creates 32 bit color.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.ColorFormat">
			<summary>Enumeration of all color formats.
A color format specifies how color information is stored.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.A16B16G16R16F">
			<summary>64 bit floating point format. 16 bits are used for the red, green, blue and alpha channels.

Note: this format may only be used for render target textures.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.A1R5G5B5">
			<summary>16 bit color format used by the software driver. There are 5 bits for every color component, and a single bit is left for alpha information.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.A32B32G32R32F">
			<summary>128 bit floating point format. 32 bits are used for the red, green, blue and alpha channels.

Note: this format may only be used for render target textures.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.A8R8G8B8">
			<summary>Default 32 bit color format. 8 bits are used for every component: red, green, blue and alpha.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.G16R16F">
			<summary>32 bit floating point format using 16 bits for the red channel and 16 bits for the green channel.

Note: this format may only be used for render target textures.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.G32R32F">
			<summary>64 bit floating point format using 32 bits for the red channel and 32 bits for the green channel.

Note: this format may only be used for render target textures.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.R16F">
			<summary>16 bit floating point format using 16 bits for the red channel.

Note: this format may only be used for render target textures.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.R32F">
			<summary>32 bit floating point format using 32 bits for the red channel.

Note: this format may only be used for render target textures.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.R5G6B5">
			<summary>Standard 16 bit color format.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.R8G8B8">
			<summary>24 bit color, no alpha channel, but 8 bit for red, green and blue.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorFormat.Unknown">
			<summary>Unknown color format.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.ColorMaterial">
			<summary>These flags allow to define the interpretation of vertex color when lighting is enabled.

Without lighting being enabled the vertex color is the only value defining the fragment color. Once lighting is enabled, the four values for diffuse, ambient, emissive, and specular take over. With these flags it is possible to define which lighting factor shall be defined by the vertex color instead of the lighting factor which is the same for all faces of that material. The default is to use vertex color for the diffuse value, another pretty common value is to use vertex color for both diffuse and ambient factor.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorMaterial.Ambient">
			<summary>Use vertex color for ambient light.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorMaterial.Diffuse">
			<summary>Use vertex color for diffuse light, this is default.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorMaterial.DiffuseAndAmbient">
			<summary>Use vertex color for both diffuse and ambient light.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorMaterial.Emissive">
			<summary>Use vertex color for emissive light.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorMaterial.None">
			<summary>Don't use vertex color for lighting.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorMaterial.Specular">
			<summary>Use vertex color for specular light.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.ColorPlane">
			<summary>Enumerates values for enabling/disabling color planes for rendering.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorPlane.All">
			<summary>All planes enabled.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorPlane.Alpha">
			<summary>Alpha enabled.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorPlane.Blue">
			<summary>Blue enabled.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorPlane.Green">
			<summary>Green enabled.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorPlane.None">
			<summary>No color enabled.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorPlane.Red">
			<summary>Red enabled.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.ColorPlane.RGB">
			<summary>All colors, no alpha.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.DriverType">
			<summary>Enumerates all supported driver types.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.DriverType.BurningsVideo">
			<summary>The Burning's Software Renderer, an alternative software renderer.

Basically it can be described as the Irrlicht Software renderer on steroids. It rasterizes 3D geometry perfectly: It is able to perform correct 3d clipping, perspective correct texture mapping, perspective correct color mapping, and renders sub pixel correct, sub texel correct primitives. In addition, it does bilinear texel filtering and supports more materials than the Software driver.

This renderer has been written entirely by Thomas Alten, thanks a lot for this huge contribution.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.DriverType.Direct3D8">
			<summary>Direct3D8 device, only available on Win32 platforms.

Performs hardware accelerated rendering of 3D and 2D primitives.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.DriverType.Direct3D9">
			<summary>Direct3D 9 device, only available on Win32 platforms.

Performs hardware accelerated rendering of 3D and 2D primitives.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.DriverType.Null">
			<summary>Null driver, useful for applications to run the engine without visualisation.

The null device is able to load textures, but does not render and display any graphics.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.DriverType.OpenGL">
			<summary>OpenGL device, available on most platforms.

Performs hardware accelerated rendering of 3D and 2D primitives.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.DriverType.Software">
			<summary>The Irrlicht Engine Software renderer.

Runs on all platforms, with every hardware. It should only be used for 2d graphics, but it can also perform some primitive 3d functions. These 3d drawing functions are quite fast, but very inaccurate, and don't even support clipping in 3D mode.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.ExposedVideoData">
			<summary>Data describing a driver and operating system specific data.

This data can be retrived by VideoDriver.ExposedVideoData. Use this with caution. This only should be used to make it possible to extend the engine easily without modification of its source. Note: this class does not contain any valid data, if you are using the software or the null device.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.Fog">
			<summary>Fog data.

Object of this class returned by VideoDriver.Fog.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.Fog.Color">
			<summary>Color of the fog.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.Fog.Density">
			<summary>Fog density, value between 0 and 1. Only used in exponential fog mode (not linear).</summary>
		</member>
		<member name="F:IrrlichtLime.Video.Fog.End">
			<summary>Specifies where fog ends. Only used in linear fog mode (not exponential).</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Fog.#ctor">
			<summary>Creates new fog.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Fog.#ctor(IrrlichtLime.Video.Color)">
			<summary>Creates new fog.</summary>
			<param name="color">Color of the fog. Default: new Color(255, 255, 255, 0).</param>
		</member>
		<member name="M:IrrlichtLime.Video.Fog.#ctor(IrrlichtLime.Video.Color,IrrlichtLime.Video.FogType)">
			<summary>Creates new fog.</summary>
			<param name="color">Color of the fog. Default: new Color(255, 255, 255, 0).</param>
			<param name="type">Type of fog. Default: FogType.Linear.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Fog.#ctor(IrrlichtLime.Video.Color,IrrlichtLime.Video.FogType,System.Single,System.Single)">
			<summary>Creates new fog.</summary>
			<param name="color">Color of the fog. Default: new Color(255, 255, 255, 0).</param>
			<param name="type">Type of fog. Default: FogType.Linear.</param>
			<param name="start">Specifies where fog starts. Only used in linear fog mode (not exponential). Default: 50.0f.</param>
			<param name="end">Specifies where fog ends. Only used in linear fog mode (not exponential). Default: 100.0f.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Fog.#ctor(IrrlichtLime.Video.Color,IrrlichtLime.Video.FogType,System.Single,System.Single,System.Single)">
			<summary>Creates new fog.</summary>
			<param name="color">Color of the fog. Default: new Color(255, 255, 255, 0).</param>
			<param name="type">Type of fog. Default: FogType.Linear.</param>
			<param name="start">Specifies where fog starts. Only used in linear fog mode (not exponential). Default: 50.0f.</param>
			<param name="end">Specifies where fog ends. Only used in linear fog mode (not exponential). Default: 100.0f.</param>
			<param name="density">Fog density, value between 0 and 1. Only used in exponential fog mode (not linear). Default: 0.01f.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Fog.#ctor(IrrlichtLime.Video.Color,IrrlichtLime.Video.FogType,System.Single,System.Single,System.Single,System.Boolean)">
			<summary>Creates new fog.</summary>
			<param name="color">Color of the fog. Default: new Color(255, 255, 255, 0).</param>
			<param name="type">Type of fog. Default: FogType.Linear.</param>
			<param name="start">Specifies where fog starts. Only used in linear fog mode (not exponential). Default: 50.0f.</param>
			<param name="end">Specifies where fog ends. Only used in linear fog mode (not exponential). Default: 100.0f.</param>
			<param name="density">Fog density, value between 0 and 1. Only used in exponential fog mode (not linear). Default: 0.01f.</param>
			<param name="pixelFog">False for vertex fog, and true for per-pixel fog.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Fog.#ctor(IrrlichtLime.Video.Color,IrrlichtLime.Video.FogType,System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
			<summary>Creates new fog.</summary>
			<param name="color">Color of the fog. Default: new Color(255, 255, 255, 0).</param>
			<param name="type">Type of fog. Default: FogType.Linear.</param>
			<param name="start">Specifies where fog starts. Only used in linear fog mode (not exponential). Default: 50.0f.</param>
			<param name="end">Specifies where fog ends. Only used in linear fog mode (not exponential). Default: 100.0f.</param>
			<param name="density">Fog density, value between 0 and 1. Only used in exponential fog mode (not linear). Default: 0.01f.</param>
			<param name="pixelFog">False for vertex fog, and true for per-pixel fog.</param>
			<param name="rangeFog">True to enable range-based vertex fog. The distance from the viewer is used to compute the fog, not the z-coordinate. This is better, but slower. This might not be available with all drivers and fog settings.</param>
		</member>
		<member name="F:IrrlichtLime.Video.Fog.PixelFog">
			<summary>False for vertex fog, and true for per-pixel fog.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.Fog.RangeFog">
			<summary>True to enable range-based vertex fog. The distance from the viewer is used to compute the fog, not the z-coordinate. This is better, but slower. This might not be available with all drivers and fog settings.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.Fog.Start">
			<summary>Specifies where fog starts. Only used in linear fog mode (not exponential).</summary>
		</member>
		<member name="F:IrrlichtLime.Video.Fog.Type">
			<summary>Type of fog.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.FogType">
			<summary>Enumeration for the types of fog distribution.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.FogType.Exp">
			<summary>Exponential fog.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.FogType.Exp2">
			<summary>Exponential^2 fog.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.FogType.Linear">
			<summary>Linear fog.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.GeometryShaderType">
			<summary>Enumeration for geometry shader versions.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.GeometryShaderType.GS_4_0">
			<summary>Version 4.0.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.GPUProgrammingServices">
			<summary>Creation and using programs running on the GPU.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String,System.String,IrrlichtLime.Video.VertexShaderType)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderProgram. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderProgram. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderProgram">The source of the pixel shader program. This can be null if no pixel shader shall be used. Default: null.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderProgram. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,IrrlichtLime.Video.MaterialType)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderProgram. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderProgram">The source of the pixel shader program. This can be null if no pixel shader shall be used. Default: null.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderProgram. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,IrrlichtLime.Video.MaterialType,System.Int32)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderProgram. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderProgram">The source of the pixel shader program. This can be null if no pixel shader shall be used. Default: null.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderProgram. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<param name="userData">User data. This int can be set to any value and will be set as parameter to your OnSetConstants event handler.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderProgram. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderProgram">The source of the pixel shader program. This can be null if no pixel shader shall be used. Default: null.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderProgram. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderProgram">The source of the geometry shader program. This can be null if no geometry shader shall be used. Default: null.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderProgram. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType,IrrlichtLime.Scene.PrimitiveType,IrrlichtLime.Scene.PrimitiveType)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderProgram. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderProgram">The source of the pixel shader program. This can be null if no pixel shader shall be used. Default: null.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderProgram. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderProgram">The source of the geometry shader program. This can be null if no geometry shader shall be used. Default: null.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderProgram. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<param name="inType">Type of vertices passed to geometry shader. Default: PrimitiveType.Triangles.</param>
			<param name="outType">Type of vertices created by geometry shader. Default: PrimitiveType.TriangleStrip.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType,IrrlichtLime.Scene.PrimitiveType,IrrlichtLime.Scene.PrimitiveType,System.UInt32)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderProgram. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderProgram">The source of the pixel shader program. This can be null if no pixel shader shall be used. Default: null.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderProgram. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderProgram">The source of the geometry shader program. This can be null if no geometry shader shall be used. Default: null.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderProgram. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<param name="inType">Type of vertices passed to geometry shader. Default: PrimitiveType.Triangles.</param>
			<param name="outType">Type of vertices created by geometry shader. Default: PrimitiveType.TriangleStrip.</param>
			<param name="verticesOut">Maximal number of vertices created by geometry shader. If 0, maximal number supported is assumed. Default: 0.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType,IrrlichtLime.Scene.PrimitiveType,IrrlichtLime.Scene.PrimitiveType,System.UInt32,IrrlichtLime.Video.MaterialType)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderProgram. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderProgram">The source of the pixel shader program. This can be null if no pixel shader shall be used. Default: null.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderProgram. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderProgram">The source of the geometry shader program. This can be null if no geometry shader shall be used. Default: null.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderProgram. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<param name="inType">Type of vertices passed to geometry shader. Default: PrimitiveType.Triangles.</param>
			<param name="outType">Type of vertices created by geometry shader. Default: PrimitiveType.TriangleStrip.</param>
			<param name="verticesOut">Maximal number of vertices created by geometry shader. If 0, maximal number supported is assumed. Default: 0.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterial(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType,IrrlichtLime.Scene.PrimitiveType,IrrlichtLime.Scene.PrimitiveType,System.UInt32,IrrlichtLime.Video.MaterialType,System.Int32)">
			<summary>Adds a new high-level shading material renderer to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderProgram">The source of the vertex shader program. This can be null if no vertex program shall be used.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderProgram. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderProgram">The source of the pixel shader program. This can be null if no pixel shader shall be used. Default: null.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderProgram. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderProgram">The source of the geometry shader program. This can be null if no geometry shader shall be used. Default: null.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderProgram. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<param name="inType">Type of vertices passed to geometry shader. Default: PrimitiveType.Triangles.</param>
			<param name="outType">Type of vertices created by geometry shader. Default: PrimitiveType.TriangleStrip.</param>
			<param name="verticesOut">Maximal number of vertices created by geometry shader. If 0, maximal number supported is assumed. Default: 0.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<param name="userData">User data. This int can be set to any value and will be set as parameter to your OnSetConstants event handler.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.VertexShaderType)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderFileName. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderFileName. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderFileName. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,IrrlichtLime.Video.MaterialType)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderFileName. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderFileName. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,IrrlichtLime.Video.MaterialType,System.Int32)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderFileName. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderFileName. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<param name="userData">User data. This int can be set to any value and will be set as parameter to your OnSetConstants event handler.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderFileName. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderFileName. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderFileName">Text file containing the source of the geometry shader program. Set to empty string if no geometry shader shall be created. Default: empty string.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderFileName. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType,IrrlichtLime.Scene.PrimitiveType,IrrlichtLime.Scene.PrimitiveType)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderFileName. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderFileName. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderFileName">Text file containing the source of the geometry shader program. Set to empty string if no geometry shader shall be created. Default: empty string.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderFileName. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<param name="inType">Type of vertices passed to geometry shader. Default: PrimitiveType.Triangles.</param>
			<param name="outType">Type of vertices created by geometry shader. Default: PrimitiveType.TriangleStrip.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType,IrrlichtLime.Scene.PrimitiveType,IrrlichtLime.Scene.PrimitiveType,System.UInt32)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderFileName. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderFileName. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderFileName">Text file containing the source of the geometry shader program. Set to empty string if no geometry shader shall be created. Default: empty string.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderFileName. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<param name="inType">Type of vertices passed to geometry shader. Default: PrimitiveType.Triangles.</param>
			<param name="outType">Type of vertices created by geometry shader. Default: PrimitiveType.TriangleStrip.</param>
			<param name="verticesOut">Maximal number of vertices created by geometry shader. If 0, maximal number supported is assumed. Default: 0.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType,IrrlichtLime.Scene.PrimitiveType,IrrlichtLime.Scene.PrimitiveType,System.UInt32,IrrlichtLime.Video.MaterialType)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderFileName. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderFileName. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderFileName">Text file containing the source of the geometry shader program. Set to empty string if no geometry shader shall be created. Default: empty string.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderFileName. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<param name="inType">Type of vertices passed to geometry shader. Default: PrimitiveType.Triangles.</param>
			<param name="outType">Type of vertices created by geometry shader. Default: PrimitiveType.TriangleStrip.</param>
			<param name="verticesOut">Maximal number of vertices created by geometry shader. If 0, maximal number supported is assumed. Default: 0.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddHighLevelShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.VertexShaderType,System.String,System.String,IrrlichtLime.Video.PixelShaderType,System.String,System.String,IrrlichtLime.Video.GeometryShaderType,IrrlichtLime.Scene.PrimitiveType,IrrlichtLime.Scene.PrimitiveType,System.UInt32,IrrlichtLime.Video.MaterialType,System.Int32)">
			<summary>Adds a new high-level shading material renderer from file to the VideoDriver.

Currently only HLSL/D3D9 and GLSL/OpenGL are supported.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. Default: empty string.</param>
			<param name="vertexShaderEntryPoint">Name of the entry function of the vertexShaderFileName. Default: "main".</param>
			<param name="vsCompileTarget">Vertex shader version the high level shader shall be compiled to. Default: VertexShaderType.VS_1_1.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="pixelShaderEntryPoint">Name of the entry function of the pixelShaderFileName. Default: "main".</param>
			<param name="psCompileTarget">Pixel shader version the high level shader shall be compiled to. Default: PixelShaderType.PS_1_1.</param>
			<param name="geometryShaderFileName">Text file containing the source of the geometry shader program. Set to empty string if no geometry shader shall be created. Default: empty string.</param>
			<param name="geometryShaderEntryPoint">Name of the entry function of the geometryShaderFileName. Default: "main".</param>
			<param name="gsCompileTarget">Geometry shader version the high level shader shall be compiled to. Default: GeometryShaderType.GS_4_0.</param>
			<param name="inType">Type of vertices passed to geometry shader. Default: PrimitiveType.Triangles.</param>
			<param name="outType">Type of vertices created by geometry shader. Default: PrimitiveType.TriangleStrip.</param>
			<param name="verticesOut">Maximal number of vertices created by geometry shader. If 0, maximal number supported is assumed. Default: 0.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<param name="userData">User data. This int can be set to any value and will be set as parameter to your OnSetConstants event handler.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddShaderMaterial(System.String)">
			<summary>Adds a new ASM shader material renderer to the VideoDriver.

Note that it is a good idea to call VideoDriver.QueryFeature() in advance to check if the VideoDriver supports the vertex and/or pixel shader version your are using.</summary>
			<param name="vertexShaderProgram">String containing the source of the vertex shader program. This can be null if no vertex program shall be used. For DX8 programs, the will always input registers look like this: v0: position, v1: normal, v2: color, v3: texture cooridnates, v4: texture coordinates 2 if available. For DX9 programs, you can manually set the registers using the dcl_ statements.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddShaderMaterial(System.String,System.String)">
			<summary>Adds a new ASM shader material renderer to the VideoDriver.

Note that it is a good idea to call VideoDriver.QueryFeature() in advance to check if the VideoDriver supports the vertex and/or pixel shader version your are using.</summary>
			<param name="vertexShaderProgram">String containing the source of the vertex shader program. This can be null if no vertex program shall be used. For DX8 programs, the will always input registers look like this: v0: position, v1: normal, v2: color, v3: texture cooridnates, v4: texture coordinates 2 if available. For DX9 programs, you can manually set the registers using the dcl_ statements.</param>
			<param name="pixelShaderProgram">String containing the source of the pixel shader program. This can be null if you don't want to use a pixel shader. Default: null.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddShaderMaterial(System.String,System.String,IrrlichtLime.Video.MaterialType)">
			<summary>Adds a new ASM shader material renderer to the VideoDriver.

Note that it is a good idea to call VideoDriver.QueryFeature() in advance to check if the VideoDriver supports the vertex and/or pixel shader version your are using.</summary>
			<param name="vertexShaderProgram">String containing the source of the vertex shader program. This can be null if no vertex program shall be used. For DX8 programs, the will always input registers look like this: v0: position, v1: normal, v2: color, v3: texture cooridnates, v4: texture coordinates 2 if available. For DX9 programs, you can manually set the registers using the dcl_ statements.</param>
			<param name="pixelShaderProgram">String containing the source of the pixel shader program. This can be null if you don't want to use a pixel shader. Default: null.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddShaderMaterial(System.String,System.String,IrrlichtLime.Video.MaterialType,System.Int32)">
			<summary>Adds a new ASM shader material renderer to the VideoDriver.

Note that it is a good idea to call VideoDriver.QueryFeature() in advance to check if the VideoDriver supports the vertex and/or pixel shader version your are using.</summary>
			<param name="vertexShaderProgram">String containing the source of the vertex shader program. This can be null if no vertex program shall be used. For DX8 programs, the will always input registers look like this: v0: position, v1: normal, v2: color, v3: texture cooridnates, v4: texture coordinates 2 if available. For DX9 programs, you can manually set the registers using the dcl_ statements.</param>
			<param name="pixelShaderProgram">String containing the source of the pixel shader program. This can be null if you don't want to use a pixel shader. Default: null.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<param name="userData">User data. This int can be set to any value and will be set as parameter to your OnSetConstants event handler.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddShaderMaterialFromFiles(System.String)">
			<summary>Adds a new ASM shader material renderer from file to the VideoDriver.

Note that it is a good idea to call VideoDriver.QueryFeature() in advance to check if the VideoDriver supports the vertex and/or pixel shader version your are using.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddShaderMaterialFromFiles(System.String,System.String)">
			<summary>Adds a new ASM shader material renderer from file to the VideoDriver.

Note that it is a good idea to call VideoDriver.QueryFeature() in advance to check if the VideoDriver supports the vertex and/or pixel shader version your are using.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.MaterialType)">
			<summary>Adds a new ASM shader material renderer from file to the VideoDriver.

Note that it is a good idea to call VideoDriver.QueryFeature() in advance to check if the VideoDriver supports the vertex and/or pixel shader version your are using.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.GPUProgrammingServices.AddShaderMaterialFromFiles(System.String,System.String,IrrlichtLime.Video.MaterialType,System.Int32)">
			<summary>Adds a new ASM shader material renderer from file to the VideoDriver.

Note that it is a good idea to call VideoDriver.QueryFeature() in advance to check if the VideoDriver supports the vertex and/or pixel shader version your are using.</summary>
			<param name="vertexShaderFileName">Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created.</param>
			<param name="pixelShaderFileName">Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. Default: empty string.</param>
			<param name="baseMaterial">Base material to use. Default: MaterialType.Solid.</param>
			<param name="userData">User data. This int can be set to any value and will be set as parameter to your OnSetConstants event handler.</param>
			<returns>Material type which can be set in Material.MaterialType to use the renderer. "(int)-1" is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log.</returns>
		</member>
		<member name="E:IrrlichtLime.Video.GPUProgrammingServices.OnSetConstants">
			<summary>Event raises before OnSetMaterial. Making it possible to set constants for gpu programs every frame.</summary>
		</member>
		<member name="E:IrrlichtLime.Video.GPUProgrammingServices.OnSetMaterial">
			<summary>Event raises after OnSetConstants.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.GPUProgrammingServices.SetConstantsHandler">
			<summary>Event raises before OnSetMaterial. Making it possible to set constants for gpu programs every frame.</summary>
			<param name="services">Provides methods to set the constants for the shader.</param>
			<param name="userData">User data which you have specified when creating the shader.</param>
		</member>
		<member name="T:IrrlichtLime.Video.GPUProgrammingServices.SetMaterialHandler">
			<summary>Event raises after OnSetConstants.</summary>
			<param name="material">Shader material.</param>
		</member>
		<member name="T:IrrlichtLime.Video.Image">
			<summary>Software image data.

Image loaders create these images from files. VideoDriver convert these images into their (hardware) textures.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Image.AlphaMask">
			<summary>Mask for alpha value of a pixel.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Image.BitsPerPixel">
			<summary>Bits per one pixel.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Image.BlueMask">
			<summary>Mask for blue value of a pixel.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Image.BytesPerPixel">
			<summary>Bytes per one pixel.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Image.ColorFormat">
			<summary>Color format of the image.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyTo(IrrlichtLime.Video.Image)">
			<summary>Copies this image to the target.</summary>
			<param name="target">Target image.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyTo(IrrlichtLime.Video.Image,IrrlichtLime.Core.Vector2Di)">
			<summary>Copies this image to the target.</summary>
			<param name="target">Target image.</param>
			<param name="targetPos">Target position. Default: (0, 0).</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyTo(IrrlichtLime.Video.Image,IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Recti)">
			<summary>Copies this image to the target.</summary>
			<param name="target">Target image.</param>
			<param name="targetPos">Target position.</param>
			<param name="sourceRect">Source rectangle.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyTo(IrrlichtLime.Video.Image,IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Recti,IrrlichtLime.Core.Recti)">
			<summary>Copies this image to the target.</summary>
			<param name="target">Target image.</param>
			<param name="targetPos">Target position.</param>
			<param name="sourceRect">Source rectangle.</param>
			<param name="clipRect">Clipping rectangle. Use null if you do not want to specify it. Default: null.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyToScaling(IrrlichtLime.Video.Image)">
			<summary>Copies this image to the target, scaling the image to fit.</summary>
			<param name="target">Target image.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyToScaling(System.Byte[],System.Int32,System.Int32)">
			<summary>Copies this image to the target, scaling the image to fit.</summary>
			<param name="target">Target image.</param>
			<param name="width">Target width.</param>
			<param name="height">Target height.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyToScaling(System.Byte[],System.Int32,System.Int32,IrrlichtLime.Video.ColorFormat)">
			<summary>Copies this image to the target, scaling the image to fit.</summary>
			<param name="target">Target image.</param>
			<param name="width">Target width.</param>
			<param name="height">Target height.</param>
			<param name="format">Target color format. Default: ColorFormat.A8R8G8B8.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyToScaling(System.Byte[],System.Int32,System.Int32,IrrlichtLime.Video.ColorFormat,System.Int32)">
			<summary>Copies this image to the target, scaling the image to fit.</summary>
			<param name="target">Target image.</param>
			<param name="width">Target width.</param>
			<param name="height">Target height.</param>
			<param name="format">Target color format. Default: ColorFormat.A8R8G8B8.</param>
			<param name="pitch">Targe pitch size. Default: 0.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyToScalingBoxFilter(IrrlichtLime.Video.Image)">
			<summary>Copies this image to the target, scaling it to fit, appyling a box filter.</summary>
			<param name="target">Target image.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyToScalingBoxFilter(IrrlichtLime.Video.Image,System.Int32)">
			<summary>Copies this image to the target, scaling it to fit, appyling a box filter.</summary>
			<param name="target">Target image.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyToScalingBoxFilter(IrrlichtLime.Video.Image,System.Int32,System.Boolean)">
			<summary>Copies this image to the target, scaling it to fit, appyling a box filter.</summary>
			<param name="target">Target image.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyToWithAlpha(IrrlichtLime.Video.Image,IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Recti,IrrlichtLime.Video.Color)">
			<summary>Copies this image to the target, using the alpha mask, and clipping rectangle and a color to add with.</summary>
			<param name="target">Target image.</param>
			<param name="targetPos">Target position.</param>
			<param name="sourceRect">Source rectangle.</param>
			<param name="color">Color to add with.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.CopyToWithAlpha(IrrlichtLime.Video.Image,IrrlichtLime.Core.Vector2Di,IrrlichtLime.Core.Recti,IrrlichtLime.Video.Color,IrrlichtLime.Core.Recti)">
			<summary>Copies this image to the target, using the alpha mask, and clipping rectangle and a color to add with.</summary>
			<param name="target">Target image.</param>
			<param name="targetPos">Target position.</param>
			<param name="sourceRect">Source rectangle.</param>
			<param name="color">Color to add with.</param>
			<param name="clipRect">Clipping rectangle. Use null if you do not want to specify it. Default: null.</param>
		</member>
		<member name="P:IrrlichtLime.Video.Image.Dimension">
			<summary>Width and height of the image.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Image.Fill(IrrlichtLime.Video.Color)">
			<summary>Fills the image data with specified color.</summary>
			<param name="color">Color to fill with.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.GetBitsPerPixelFromFormat(IrrlichtLime.Video.ColorFormat)">
			<summary>Gets the amount of bits per one pixel for the given color format.</summary>
			<param name="format">Color format.</param>
			<returns>Amount of bits.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.Image.GetPixel(System.Int32,System.Int32)">
			<summary>Gets color of the pixel in specified coordinates.</summary>
			<param name="x">X coord.</param>
			<param name="y">Y coord.</param>
			<returns>Color of the pixel.</returns>
		</member>
		<member name="P:IrrlichtLime.Video.Image.GreenMask">
			<summary>Mask for green value of a pixel.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Image.ImageDataSizeInBytes">
			<summary>Image data size in bytes.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Image.ImageDataSizeInPixels">
			<summary>Image data size in pixels.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Image.IsRenderTargetOnlyFormat(IrrlichtLime.Video.ColorFormat)">
			<summary>Tests if the color format is only viable for RTT (render target textures).</summary>
			<param name="format">Color format to test.</param>
			<returns>True if color format is only for RTT.</returns>
		</member>
		<member name="P:IrrlichtLime.Video.Image.Pitch">
			<summary>Pitch size of the image.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Image.RedMask">
			<summary>Mask for red value of a pixel.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Image.SetPixel(System.Int32,System.Int32,IrrlichtLime.Video.Color)">
			<summary>Sets pixel's color at specified coordinates.</summary>
			<param name="x">X coord.</param>
			<param name="y">Y coord.</param>
			<param name="color">Color to set.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Image.SetPixel(System.Int32,System.Int32,IrrlichtLime.Video.Color,System.Boolean)">
			<summary>Sets pixel's color at specified coordinates.</summary>
			<param name="x">X coord.</param>
			<param name="y">Y coord.</param>
			<param name="color">Color to set.</param>
			<param name="blend">Shoud color be blended (true) or replaced (false) ? Default: false.</param>
		</member>
		<member name="T:IrrlichtLime.Video.ImageLoader">
			<summary>Class which is able to create a image from a file.

If you want the Irrlicht Engine be able to load textures of currently unsupported file formats (e.g .gif), then implement this and add your new image loader with VideoDriver.AddExternalImageLoader() to the engine.

NOTE: currently Irrlicht Lime does not support extending engine with your own image loaders.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.ImageLoader.IsLoadableFileExtension(System.String)">
			<summary>Checks if the file might be loaded by this image loader.

Check is based on the file extension (e.g. ".tga").</summary>
			<param name="filename">Name of file to check.</param>
			<returns>True if file seems to be loadable.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.ImageLoader.IsLoadableFileFormat(IrrlichtLime.IO.ReadFile)">
			<summary>Checks if the file might be loaded by this image loader.

Check might look into the file.</summary>
			<param name="file">File to check.</param>
			<returns>True if file seems to be loadable.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.ImageLoader.LoadImage(IrrlichtLime.IO.ReadFile)">
			<summary>Loads an image from the file.</summary>
			<param name="file">File to load from.</param>
			<returns>Newly created image or null if error occured.</returns>
		</member>
		<member name="T:IrrlichtLime.Video.IndexType">
			<summary>Enumeration for available index types.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.IndexType._16Bit">
			<summary>16 bit indexes.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.IndexType._32Bit">
			<summary>32 bit indexes.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.Light">
			<summary>Describes a dynamic point light.

Irrlicht Engine supports point lights, spot lights, and directional lights.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.AmbientColor">
			<summary>Ambient color emitted by the light.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.Attenuation">
			<summary>Attenuation factors (constant, linear, quadratic).

Changes the light strength fading over distance. Can also be altered by setting the radius, Attenuation will change to (0,1.f/radius,0). Can be overridden after radius was set.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.CastShadows">
			<summary>Indicate that the light casts shadows.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.DiffuseColor">
			<summary>Diffuse color emitted by the light.

This is the primary color you want to set.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.Direction">
			<summary>Direction of the light.

If Type == LightType.Point, it is ignored.
Changed via light scene node's rotation.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.Falloff">
			<summary>The light strength's decrease between Outer and Inner cone.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.InnerCone">
			<summary>The angle of the spot's inner cone. Ignored for other types of light.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Light.#ctor">
			<summary>Constructs default light.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.OuterCone">
			<summary>The angle of the spot's outer cone. Ignored for other types of light.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.Position">
			<summary>Position of the light.

If Type == LightType.Directional, it is ignored.
Changed via light scene node's position.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.Radius">
			<summary>Radius of light. Everything within this radius will be lighted.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.SpecularColor">
			<summary>Specular color emitted by the light.

For details how to use specular highlights, see Material.Shininess.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Light.Type">
			<summary>Type of the light.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.LightType">
			<summary>Enumeration for different types of lights.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.LightType.Directional">
			<summary>Directional light, coming from a direction from an infinite distance.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.LightType.Point">
			<summary>Point light, it has a position in space and radiates light in all directions.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.LightType.Spot">
			<summary>Spot light, it has a position in space, a direction, and a limited cone of influence.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.Material">
			<summary>Holds parameters for a material renderer.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.AmbientColor">
			<summary>How much ambient light (a global light) is reflected by this material.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.AntiAliasing">
			<summary>Antialiasing mode.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.BackfaceCulling">
			<summary>Is backface culling enabled? Default: true.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.ColorMask">
			<summary>Defines the enabled color planes.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.ColorMaterial">
			<summary>Defines the interpretation of vertex color in the lighting equation. When lighting is enabled, vertex color can be used instead of the material values for light modulation. This allows to easily change e.g. the diffuse light behavior of each face. Default: ColorMaterial.Diffuse.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.DiffuseColor">
			<summary>How much diffuse light coming from a light source is reflected by this material.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.EmissiveColor">
			<summary>Light emitted by this material. Default is to emit no light.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.Fog">
			<summary>Is fog enabled? Default: false.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.FrontfaceCulling">
			<summary>Is frontface culling enabled? Default: false.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Material.GetFlag(IrrlichtLime.Video.MaterialFlag)">
			<summary>Gets the value of material flag.</summary>
			<param name="flag">The flag to query.</param>
			<returns>The current value of the flag.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.Material.GetTexture(System.Int32)">
			<summary>Gets the texture from specified texture level.</summary>
			<param name="index">The desired texture level. Must be less than Material.MaxTextures.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Material.GetTextureMatrix(System.Int32)">
			<summary>Gets the texture transformation matrix.</summary>
			<param name="index">The desired texture level. Must be less than Material.MaxTextures.</param>
		</member>
		<member name="P:IrrlichtLime.Video.Material.GouraudShading">
			<summary>Flat or Gouraud shading? Default: true.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.Layer">
			<summary>Material layers.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.Lighting">
			<summary>Will this material be lighted? Default: true.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Material.#ctor">
			<summary>Default constructor. Creates a solid, lit material with white colors.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Material.#ctor(IrrlichtLime.Video.Material)">
			<summary>Copy constructor.</summary>
			<param name="other">Material to copy from.</param>
		</member>
		<member name="P:IrrlichtLime.Video.Material.MaterialTypeParam">
			<summary>Free parameter, dependent on the material type.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.MaterialTypeParam2">
			<summary>Second free parameter, dependent on the material type.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.MaxTextures">
			<summary>Maximum number of textures a Material can have.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.Mipmaps">
			<summary>Shall mipmaps be used if available? Default: true.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.NormalizeNormals">
			<summary>Should normals be normalized? Always use this if the mesh lit and scaled. Default: false.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.PointCloud">
			<summary>Draw as point cloud or filled triangles? Default: false.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Material.SetFlag(IrrlichtLime.Video.MaterialFlag,System.Boolean)">
			<summary>Sets the value of material flag.</summary>
			<param name="flag">The flag to set.</param>
			<param name="value">The new value to set.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Material.SetTexture(System.Int32,IrrlichtLime.Video.Texture)">
			<summary>Sets the texture of specified texture level.</summary>
			<param name="index">The desired texture level. Must be less than Material.MaxTextures.</param>
			<param name="tex">Texture to set.</param>
		</member>
		<member name="M:IrrlichtLime.Video.Material.SetTextureMatrix(System.Int32,IrrlichtLime.Core.Matrix)">
			<summary>Sets the texture transformation matrix.</summary>
			<param name="index">The desired texture level. Must be less than Material.MaxTextures.</param>
			<param name="mat">Texture matrix for texture level.</param>
		</member>
		<member name="P:IrrlichtLime.Video.Material.Shininess">
			<summary>Value affecting the size of specular highlights.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.SpecularColor">
			<summary>How much specular light (highlights from a light) is reflected.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.Thickness">
			<summary>Thickness of non-3dimensional elements such as lines and points.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.Transparent">
			<summary>Is this material transparent.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.Type">
			<summary>Type of the material. Specifies how everything is blended together.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.Wireframe">
			<summary>Draw as wireframe or filled triangles? Default: false.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.ZBuffer">
			<summary>Is the ZBuffer enabled? Default: ZBufferCompFunc.LessEqual.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Material.ZWrite">
			<summary>Is the z-buffer writeable or is it read-only. Default: true.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.MaterialFlag">
			<summary>Material flags.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.AnisotropicFilter">
			<summary>Is anisotropic filtering? Default: false.

In Irrlicht you can use anisotropic texture filtering in conjunction with bilinear or trilinear texture filtering to improve rendering results. Primitives will look less blurry with this flag switched on.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.AntiAliasing">
			<summary>AntiAliasing mode.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.BackFaceCulling">
			<summary>Is backface culling enabled? Default: true.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.BilinearFilter">
			<summary>Is bilinear filtering enabled? Default: true.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.ColorMask">
			<summary>ColorMask bits, for enabling the color planes.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.ColorMaterial">
			<summary>ColorMaterial enum for vertex color interpretation.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.Fog">
			<summary>Is fog enabled? Default: false.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.FrontFaceCulling">
			<summary>Is frontface culling enabled? Default: false.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.GouraudShading">
			<summary>Flat or Gouraud shading? Default: true.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.Lighting">
			<summary>Will this material be lighted? Default: true.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.Mipmaps">
			<summary>Enable/disable mipmaps usage.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.NormalizeNormals">
			<summary>Normalizes normals. Default: false.

You can enable this if you need to scale a dynamic lighted model. Usually, its normals will get scaled too then and it will get darker. If you enable the this flag, the normals will be normalized again, and the model will look as bright as it should.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.PointCloud">
			<summary>Draw as point cloud or filled triangles? Default: false.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.TextureWrap">
			<summary>Access to all layers texture wrap settings. Overwrites separate layer settings.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.TrilinearFilter">
			<summary>Is trilinear filtering enabled? Default: false.

If the trilinear filter flag is enabled, the bilinear filtering flag is ignored.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.Wireframe">
			<summary>Draw as wireframe or filled triangles? Default: false.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.ZBuffer">
			<summary>Is the ZBuffer enabled? Default: true.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialFlag.ZWrite">
			<summary>May be written to the zbuffer or is it readonly. Default: true.

This flag is ignored, if the material type is a transparent type.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.MaterialLayer">
			<summary>Holds material parameters which exist per texture layer.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialLayer.AnisotropicFilter">
			<summary>Is anisotropic filtering enabled? Default: 0 (disabled).

In Irrlicht you can use anisotropic texture filtering in conjunction with bilinear or trilinear texture filtering to improve rendering results. Primitives will look less blurry with this flag switched on. The number gives the maximal anisotropy degree, and is often in the range 2-16. Value 1 is equivalent to 0, but should be avoided.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialLayer.BilinearFilter">
			<summary>Is bilinear filtering enabled? Default: true.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialLayer.LODBias">
			<summary>Bias for the mipmap choosing decision.

This value can make the textures more or less blurry than with the default value of 0. The value (divided by 8.0f) is added to the mipmap level chosen initially, and thus takes a smaller mipmap for a region if the value is positive.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.MaterialLayer.#ctor">
			<summary>Constructs default material layer.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialLayer.Texture">
			<summary>The texture.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialLayer.TextureMatrix">
			<summary>The texture transformation matrix.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialLayer.TextureWrapU">
			<summary>Texture Clamp mode by U axis.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialLayer.TextureWrapV">
			<summary>Texture Clamp mode by V axis.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialLayer.TrilinearFilter">
			<summary>Is trilinear filtering enabled? Default: false.

If this flag is enabled, the bilinear filtering flag is ignored.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.MaterialRenderer">
			<summary>Material renderer info.

Can be used to extend the engine with new materials. Refer to VideoDriver.AddMaterialRenderer() and GPUProgrammingServices.Add*() for more information on how to extend the engine with new materials.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialRenderer.Capability">
			<summary>The render capability of the material.

Because some more complex materials are implemented in multiple ways and need special hardware capabilities, it is possible to query how the current material renderer is performing on the current hardware.

0 if everything is running fine. Any other value is material renderer specific and means for example that the renderer switched back to a fall back material because it cannot use the latest shaders. More specific examples: Fixed function pipeline materials should return 0 in most cases, parallax mapped material will only return 0 when at least pixel shader 1.4 is available on that machine.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialRenderer.Transparent">
			<summary>True is the material is transparent.

The scene managment needs to know this for being able to sort the materials by opaque and transparent.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.MaterialRendererServices">
			<summary>Provides some methods for changing advanced, internal states of a VideoDriver.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.MaterialRendererServices.SetBasicRenderStates(IrrlichtLime.Video.Material,IrrlichtLime.Video.Material,System.Boolean)">
			<summary>Can be called by a MaterialRenderer to make its work easier.

Sets all basic render states if needed. Basic render states are diffuse, ambient, specular, and emissive color, specular power, bilinear and trilinear filtering, wireframe mode, grouraudshading, lighting, zbuffer, zwriteenable, backfaceculling and fog enabling.</summary>
			<param name="newMaterial">The new material to be used.</param>
			<param name="lastMaterial">The material used until now.</param>
			<param name="resetAllRenderStates">Set to true if all renderstates should be set, regardless of their current state.</param>
		</member>
		<member name="M:IrrlichtLime.Video.MaterialRendererServices.SetPixelShaderRegisters(System.Int32,System.Single[])">
			<summary>Sets a pixel shader register (s).

Can be used if you created a shader using pixel/vertex shader assembler or ARB_fragment_program or ARB_vertex_program.</summary>
			<param name="startRegisterIndex">First register to be set.</param>
			<param name="values">Data to be set in the registers. One register consists of 4 floats. Note: the length of this array must be multiple of 4.</param>
		</member>
		<member name="M:IrrlichtLime.Video.MaterialRendererServices.SetPixelShaderVariable(System.String,System.Single[])">
			<summary>Sets a variable for the pixel shader based on the name.

This can be used if you used a high level shader language like GLSL or HLSL to create a shader.</summary>
			<param name="name">Name of the variable.</param>
			<param name="values">Array of floats (the value of the variable).</param>
			<returns>True if successful.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.MaterialRendererServices.SetVertexShaderRegisters(System.Int32,System.Single[])">
			<summary>Sets a vertex shader register(s).

Can be used if you created a shader using pixel/vertex shader assembler or ARB_fragment_program or ARB_vertex_program.</summary>
			<param name="startRegisterIndex">First register to be set.</param>
			<param name="values">Data to be set in the registers. One register consists of 4 floats. Note: the length of this array must be multiple of 4.</param>
		</member>
		<member name="M:IrrlichtLime.Video.MaterialRendererServices.SetVertexShaderVariable(System.String,System.Single[])">
			<summary>Sets a variable for the vertex shader based on the name.

This can be used if you used a high level shader language like GLSL or HLSL to create a shader.</summary>
			<param name="name">Name of the variable.</param>
			<param name="values">Array of floats (the value of the variable).</param>
			<returns>True if successful.</returns>
		</member>
		<member name="P:IrrlichtLime.Video.MaterialRendererServices.VideoDriver">
			<summary>Pointer to the VideoDriver.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.MaterialType">
			<summary>Abstracted and easy to use fixed function/programmable pipeline material modes.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.DetailMap">
			<summary>Detail mapped material.

The first texture is diffuse color map, the second is added to this and usually displayed with a bigger scale value so that it adds more detail. The detail map is added to the diffuse map using ADD_SIGNED, so that it is possible to add and substract color from the diffuse map. For example a value of (127,127,127) will not change the appearance of the diffuse map at all. Often used for terrain rendering.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.LightMap">
			<summary>Material type with standard lightmap technique.

There should be 2 textures: The first texture layer is a diffuse map, the second is a light map. Dynamic light is ignored.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.LightMapAdd">
			<summary>Material type with lightmap technique like MaterialType.LightMap.

But lightmap and diffuse texture are added instead of modulated.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.LightMapLighting">
			<summary>Like MaterialType.LightMap, but also supports dynamic lighting.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.LightMapLightingM2">
			<summary>Like MaterialType.LightMapM2, but also supports dynamic lighting.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.LightMapLightingM4">
			<summary>Like MaterialType.LightMapM4, but also supports dynamic lighting.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.LightMapM2">
			<summary>Material type with standard lightmap technique.

There should be 2 textures: The first texture layer is a diffuse map, the second is a light map. Dynamic light is ignored. The texture colors are effectively multiplied by 2 for brightening. Like known in DirectX as D3DTOP_MODULATE2X.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.LightMapM4">
			<summary>Material type with standard lightmap technique.

There should be 2 textures: The first texture layer is a diffuse map, the second is a light map. Dynamic light is ignored. The texture colors are effectively multiplied by 4 for brightening. Like known in DirectX as D3DTOP_MODULATE4X.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.NormalMapSolid">
			<summary>A solid normal map renderer.

First texture is the color map, the second should be the normal map. Note that you should use this material only when drawing geometry consisting of vertices of type Vertex3DTangents (VertexType.Tangents). You can convert any mesh into this format using MeshManipulator.CreateMeshWithTangents(). This shader runs on vertex shader 1.1 and pixel shader 1.1 capable hardware and falls back to a fixed function lighted material if this hardware is not available. Only two lights are supported by this shader, if there are more, the nearest two are chosen.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.NormalMapTransparentAddColor">
			<summary>A transparent normal map renderer.

First texture is the color map, the second should be the normal map. Note that you should use this material only when drawing geometry consisting of vertices of type Vertex3DTangents (VertexType.Tangents). You can convert any mesh into this format using MeshManipulator.CreateMeshWithTangents(). This shader runs on vertex shader 1.1 and pixel shader 1.1 capable hardware and falls back to a fixed function lighted material if this hardware is not available. Only two lights are supported by this shader, if there are more, the nearest two are chosen.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.NormalMapTransparentVertexAlpha">
			<summary>A transparent (based on the vertex alpha value) normal map renderer.

First texture is the color map, the second should be the normal map. Note that you should use this material only when drawing geometry consisting of vertices of type Vertex3DTangents (VertexType.Tangents). You can convert any mesh into this format using MeshManipulator.CreateMeshWithTangents(). This shader runs on vertex shader 1.1 and pixel shader 1.1 capable hardware and falls back to a fixed function lighted material if this hardware is not available. Only two lights are supported by this shader, if there are more, the nearest two are chosen.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.OneTextureBlend">
			<summary>BlendFunc = source * sourceFactor + dest * destFactor (E_BLEND_FUNC).

Using only first texture. Generic blending method.

&lt;&lt;&lt; incompleted !!! what is E_BLEND_FUNC ??? &gt;&gt;&gt;</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.ParallaxMapSolid">
			<summary>Just like MaterialType.NormalMapSolid, but uses parallax mapping.

Looks a lot more realistic. This only works when the hardware supports at least vertex shader 1.1 and pixel shader 1.4. First texture is the color map, the second should be the normal map. The normal map texture should contain the height value in the alpha component. The VideoDriver.MakeNormalMapTexture() method writes this value automatically when creating normal maps from a heightmap when using a 32 bit texture. The height scale of the material (affecting the bumpiness) is being controlled by the Material.MaterialTypeParam member. If set to zero, the default value (0.02f) will be applied. This value depends on with which scale the texture is mapped on the material. Too high or low values of Material.MaterialTypeParam can result in strange artifacts.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.ParallaxMapTransparentAddColor">
			<summary>A material like MaterialType.ParallaxMapSolid, but transparent.

Using MaterialType.TransparentAddColor as base material.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.ParallaxMapTransparentVertexAlpha">
			<summary>A material like MaterialType.ParallaxMapSolid, but transparent.

Using MaterialType.TransparentVertexAlpha as base material.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.Reflection2Layer">
			<summary>A reflecting material with an optional non reflecting texture layer.

The reflection map should be set as first texture.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.Solid">
			<summary>Standard solid material.

Only first texture is used, which is supposed to be the diffuse material.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.Solid2Layer">
			<summary>Solid material with 2 texture layers.

The second is blended onto the first using the alpha value of the vertex colors. This material is currently not implemented in OpenGL.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.SphereMap">
			<summary>Look like a reflection of the environment around it.

To make this possible, a texture called 'sphere map' is used, which must be set as the first texture.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.TransparentAddColor">
			<summary>A transparent material.

Only the first texture is used. The new color is calculated by simply adding the source color and the dest color. This means if for example a billboard using a texture with black background and a red circle on it is drawn with this material, the result is that only the red circle will be drawn a little bit transparent, and everything which was black is 100% transparent and not visible. This material type is useful for particle effects.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.TransparentAlphaChannel">
			<summary>Makes the material transparent based on the texture alpha channel.

The final color is blended together from the destination color and the texture color, using the alpha channel value as blend factor. Only first texture is used. If you are using this material with small textures, it is a good idea to load the texture in 32 bit mode (VideoDriver.SetTextureCreationFlag()). Also, an alpha ref is used, which can be manipulated using Material.MaterialTypeParam. This value controls how sharp the edges become when going from a transparent to a solid spot on the texture.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.TransparentAlphaChannelRef">
			<summary>Makes the material transparent based on the texture alpha channel.

If the alpha channel value is greater than 127, a pixel is written to the target, otherwise not. This material does not use alpha blending and is a lot faster than MaterialType.TransparentAlphaChannel. It is ideal for drawing stuff like leafes of plants, because the borders are not blurry but sharp. Only first texture is used. If you are using this material with small textures and 3d object, it is a good idea to load the texture in 32 bit mode (VideoDriver.SetTextureCreationFlag()).</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.TransparentReflection2Layer">
			<summary>A transparent reflecting material with an optional additional non reflecting texture layer.

The reflection map should be set as first texture. The transparency depends on the alpha value in the vertex colors. A texture which will not reflect can be set as second texture. Please note that this material type is currently not completely implemented in OpenGL.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.MaterialType.TransparentVertexAlpha">
			<summary>Makes the material transparent based on the vertex alpha value.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.PixelShaderType">
			<summary>Enumeration for pixel shader versions.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_1_1">
			<summary>Version 1.1.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_1_2">
			<summary>Version 1.2.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_1_3">
			<summary>Version 1.3.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_1_4">
			<summary>Version 1.4.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_2_0">
			<summary>Version 2.0.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_2_a">
			<summary>Version 2.a.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_2_b">
			<summary>Version 2.b.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_3_0">
			<summary>Version 3.0.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_4_0">
			<summary>Version 4.0.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_4_1">
			<summary>Version 4.1.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.PixelShaderType.PS_5_0">
			<summary>Version 5.0.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.RenderTarget">
			<summary>Special render targets, which usually map to dedicated hardware.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer0">
			<summary>Auxiliary buffer 0.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer1">
			<summary>Auxiliary buffer 1.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer2">
			<summary>Auxiliary buffer 2.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer3">
			<summary>Auxiliary buffer 3.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.AuxBuffer4">
			<summary>Auxiliary buffer 4.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.FrameBuffer">
			<summary>Render target is the main color frame buffer.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.MultiRenderTexture">
			<summary>Multi-Render target textures.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.RenderTexture">
			<summary>Render target is a render texture.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.StereoBothBuffers">
			<summary>Render to both stereo buffers at once.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.StereoLeftBuffer">
			<summary>Render target is the main color frame buffer.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.RenderTarget.StereoRightBuffer">
			<summary>Render target is the right color buffer (left is the main buffer).</summary>
		</member>
		<member name="T:IrrlichtLime.Video.Texture">
			<summary>Video driver dependent texture.

Texture can be created using VideoDriver.AddTexture() or VideoDriver.GetTexture(). After that, the texture may only be used by this VideoDriver. As you can imagine, textures of the DirectX and the OpenGL device will, e.g., not be compatible. An exception is the Software device and the NULL device, their textures are compatible. If you try to use a texture created by one device with an other device, the device will refuse to do that and write a warning or an error message to the log.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Texture.AlphaChannel">
			<summary>Texture has an alpha channel.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Texture.ColorFormat">
			<summary>Color format of the texture.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Texture.DriverType">
			<summary>Gets driver type of the texture.

This is the driver, which created the texture. This method is used internally by the video devices, to check, if they may use a texture because textures may be incompatible between different devices.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Texture.GetTexturePainter">
			<summary>Gets texture painter for this texture.

Note: you can use returned TexturePainter pointer as long as you sure that texture not dropped.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Texture.MipMaps">
			<summary>Texture has mip map levels.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Texture.Name">
			<summary>Name of the texture (in most cases this is the filename).</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Texture.OriginalSize">
			<summary>Original size of the texture.

The texture is usually scaled, if it was created with an unoptimal size. For example if the size was not a power of two. This method returns the size of the texture it had before it was scaled. Can be useful when drawing 2d images on the screen, which should have the exact size of the original texture. Use Texture.Size if you want to know the real size it has now stored in the system.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Texture.Pitch">
			<summary>Pitch of the texture (in bytes).

The pitch is the amount of bytes used for a row of pixels in a texture.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.Texture.RegenerateMipMapLevels">
			<summary>Regenerates the mip map levels of the texture.

Required in most cases after modifying the texture using the object returned by GetTexturePainter(). Regeneration of mip map levels done in next way: the main level (most detailed level: level 0) is left untoched, all other levels will get automatic regeneration. This means that if you use TexturePainter and draw on different mip map levels, propbably you should not call this method, since only level 0 will contain your unique changes.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Texture.RenderTarget">
			<summary>Texture is a render target.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.Texture.Size">
			<summary>Size of the texture.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.TextureClamp">
			<summary>Texture coord clamp mode outside [0.0, 1.0].</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureClamp.Clamp">
			<summary>Texture is clamped to the last pixel.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureClamp.ClampToBorder">
			<summary>Texture is clamped to the border pixel (if exists).</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureClamp.ClampToEdge">
			<summary>Texture is clamped to the edge pixel.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureClamp.Mirror">
			<summary>Texture is alternately mirrored (0...1...0...1..0...).</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureClamp.MirrorClamp">
			<summary>Texture is mirrored once and then clamped (0...1...0).</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureClamp.MirrorClampToBorder">
			<summary>Texture is mirrored once and then clamped to border.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureClamp.MirrorClampToEdge">
			<summary>Texture is mirrored once and then clamped to edge.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureClamp.Repeat">
			<summary>Texture repeats.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.TextureCreationFlag">
			<summary>Enumeration of flags telling the video driver in which format textures should be created.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureCreationFlag.AllowNonPower2">
			<summary>Allow the driver to use non power of 2 textures (non-POT).

Note: BurningsVideo can handle non-POT in 2D (GUI), but not in 3D.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureCreationFlag.Always16Bit">
			<summary>Forces the driver to create 16 bit textures always, independent of which format the file on disk has. When choosing this you may loose some color detail, but gain much speed and less memory usage.

When using this flag, it does not make sense to use the flags Always32Bit, OptimizedForQuality or OptimizedForSpeed at the same time.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureCreationFlag.Always32Bit">
			<summary>Forces the driver to create 32 bit textures always, independent of which format the file on disk has. Please note that some drivers (like the software device) will ignore this, because they are only able to create and use 16 bit textures.

When using this flag, it does not make sense to use the flags Always16Bit, OptimizedForQuality or OptimizedForSpeed at the same time.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureCreationFlag.CreateMipMaps">
			<summary>Automatically creates mip map levels for the textures.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureCreationFlag.NoAlphaChannel">
			<summary>Discard any alpha layer and use non-alpha color format.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureCreationFlag.OptimizedForQuality">
			<summary>Lets the driver decide in which format the textures are created and tries to make the textures look as good as possible. Usually it simply chooses the format in which the texture was stored on disk.

When using this flag, it does not make sense to use the flags Always16Bit, Always32Bit, or OptimizedForSpeed at the same time.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TextureCreationFlag.OptimizedForSpeed">
			<summary>Lets the driver decide in which format the textures are created and tries to create them maximizing render speed.

When using this flag, it does not make sense to use the flags Always16Bit, Always32Bit or OptimizedForQuality at the same time.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.TexturePainter">
			<summary>Provides ability to paint on texture's different mip map levels. Object of TexturePainter can be obtained using Texture.GetTexturePainter().

Order of usage: 1) get a Texture object; call its GetTexturePainter() and save the pointer. You can use this pointer until texture not dropped; 2) when you need access texture pixels, use Lock(), then read/write pixels, then Unlock().

Note: all the members in this class requires texture to be locked using Lock() before using them (except actually: Lock(), Texture, Locked and MipMapLevelCount).</summary>
		</member>
		<member name="M:IrrlichtLime.Video.TexturePainter.GetPixel(System.Int32,System.Int32)">
			<summary>Gets a single pixel from currently locked mip map level.</summary>
			<param name="x">X coord. Must be less than MipMapLevelWidth.</param>
			<param name="y">Y coord. Must be less than MipMapLevelHeight.</param>
			<returns>Color of the pixel.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.TexturePainter.Lock">
			<summary>Locks mip map level 0 (main level) for reading and writing.</summary>
			<returns>True on success.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.TexturePainter.Lock(System.Boolean)">
			<summary>Locks mip map level 0 (main level) for reading and writing (if needed).</summary>
			<param name="readOnly">True if read-only access needed. Default: false.</param>
			<returns>True on success.</returns>
		</member>
		<member name="M:IrrlichtLime.Video.TexturePainter.Lock(System.Boolean,System.Int32)">
			<summary>Locks certain mip map level for reading and writing (if needed).</summary>
			<param name="readOnly">True if read-only access needed. Default: false.</param>
			<param name="mipmapLevel">Mip map level to lock. Value from 0 (most detailed level) and MipMapLevelCount-1. Default: 0.</param>
			<returns>True on success.</returns>
		</member>
		<member name="P:IrrlichtLime.Video.TexturePainter.Locked">
			<summary>True if Texture is locked and you can access pixels of currently locked mip map level.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.TexturePainter.MipMapLevel">
			<summary>Currently locked mip map level.

Note: can be from 0 to MipMapLevelCount-1.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.TexturePainter.MipMapLevelCount">
			<summary>Total number of mip map levels in the texture. This value depends on the size of the texture: larger textures has more mip map levels.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.TexturePainter.MipMapLevelHeight">
			<summary>Height of currently locked mip map level.

Note: if MipMapLevel == 0, then real height of the texture is stored here.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.TexturePainter.MipMapLevelWidth">
			<summary>Width of currently locked mip map level.

Note: if MipMapLevel == 0, then real width of the texture is stored here.</summary>
		</member>
		<member name="P:IrrlichtLime.Video.TexturePainter.ReadOnly">
			<summary>Indicates read-only access mode.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.TexturePainter.SetLine(System.Int32,System.Int32,System.Int32,System.Int32,IrrlichtLime.Video.Color)">
			<summary>Draws a line on the currently locked mip map level.</summary>
			<param name="x1">X1 coord. Must be less than MipMapLevelWidth.</param>
			<param name="y1">Y1 coord. Must be less than MipMapLevelHeight.</param>
			<param name="x2">X2 coord. Must be less than MipMapLevelWidth.</param>
			<param name="y2">Y2 coord. Must be less than MipMapLevelHeight.</param>
			<param name="color">Color of the line.</param>
		</member>
		<member name="M:IrrlichtLime.Video.TexturePainter.SetPixel(System.Int32,System.Int32,IrrlichtLime.Video.Color)">
			<summary>Sets a single pixel on currently locked mip map level.</summary>
			<param name="x">X coord. Must be less than MipMapLevelWidth.</param>
			<param name="y">Y coord. Must be less than MipMapLevelHeight.</param>
			<param name="color">Color of the pixel.</param>
		</member>
		<member name="P:IrrlichtLime.Video.TexturePainter.Texture">
			<summary>Texture which is used for accessing pixels by this TexturePainter.</summary>
		</member>
		<member name="M:IrrlichtLime.Video.TexturePainter.Unlock">
			<summary>Unlocks texture previously locked by Lock().</summary>
		</member>
		<member name="M:IrrlichtLime.Video.TexturePainter.Unlock(System.Boolean)">
			<summary>Unlocks texture previously locked by Lock().</summary>
			<param name="alsoRegenerateMipMapLevels">Should Texture.RegenerateMipMapLevels() be called after unlocking? Default: false.</param>
		</member>
		<member name="T:IrrlichtLime.Video.TransformationState">
			<summary>Enumeration for geometry transformation states.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TransformationState.Projection">
			<summary>Projection transformation.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TransformationState.Texture0">
			<summary>Texture 0 transformation.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TransformationState.Texture1">
			<summary>Texture 1 transformation.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TransformationState.Texture2">
			<summary>Texture 2 transformation.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TransformationState.Texture3">
			<summary>Texture 3 transformation.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TransformationState.View">
			<summary>View transformation.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.TransformationState.World">
			<summary>World transformation.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.VertexShaderType">
			<summary>Enumeration for vertex shader versions.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexShaderType.VS_1_1">
			<summary>Version 1.1.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexShaderType.VS_2_0">
			<summary>Version 2.0.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexShaderType.VS_2_a">
			<summary>Version 2.a.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexShaderType.VS_3_0">
			<summary>Version 3.0.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexShaderType.VS_4_0">
			<summary>Version 4.0.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexShaderType.VS_4_1">
			<summary>Version 4.1.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexShaderType.VS_5_0">
			<summary>Version 5.0.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.VertexType">
			<summary>Enumeration for vertex types.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexType.Standard">
			<summary>Standard vertex type.

Vertices of this type is described by Vertex3D class.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexType.Tangents">
			<summary>Vertex with a tangent and binormal vector. Usually used for tangent space normal mapping.

Vertices of this type is described by Vertex3DTangents class.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VertexType.TTCoords">
			<summary>Vertex with two texture coordinates. Usually used for geometry with lightmaps or other special materials.

Vertices of this type is described by Vertex3DTTCoords class.</summary>
		</member>
		<member name="T:IrrlichtLime.Video.VideoDriverFeature">
			<summary>Enumeration for querying features of the video driver.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.AlphaToCoverage">
			<summary>Alpha To Coverage supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.ARB_FragmentProgram_1">
			<summary>ARB fragment programs v1.0 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.ARB_GLSL">
			<summary>GLSL supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.ARB_VertexProgram_1">
			<summary>ARB vertex programs v1.0 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.BilinearFilter">
			<summary>Driver able to render with a bilinear filter applied.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.ColorMask">
			<summary>Color masks (disabling color planes in output) supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.FrameBufferObject">
			<summary>Framebuffer objects supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.GeomertyShader">
			<summary>Geometry shaders supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.HardwareTL">
			<summary>Hardeware transform and lighting supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.HLSL">
			<summary>HLSL supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.Mipmap">
			<summary>Driver able to handle mip maps.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.MipmapAutoUpdate">
			<summary>Driver able to update mip maps automatically.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.MRT_Blend">
			<summary>Separate blend settings for multiple render targets supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.MRT_BlendFunc">
			<summary>Separate blend functions for multiple render targets supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.MRT_ColorMask">
			<summary>Separate color masks for multiple render targets supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.MultipleRenderTargets">
			<summary>Multiple render targets supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.Multitexture">
			<summary>Multiple textures per material are possible.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.OcclusionQuery">
			<summary>Occlusion queries supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_1_1">
			<summary>Pixel shader version 1.1 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_1_2">
			<summary>Pixel shader version 1.2 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_1_3">
			<summary>Pixel shader version 1.3 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_1_4">
			<summary>Pixel shader version 1.4 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_2_0">
			<summary>Pixel shader version 2.0 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.PixelShader_3_0">
			<summary>Pixel shader version 3.0 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.RenderToTarget">
			<summary>Driver able to render to a surface.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.StencilBuffer">
			<summary>Stencil buffers switched on and the device supports stencil buffers.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureNonPOT">
			<summary>Non-power-of-two (Non-POT) textures supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.TextureNonSquare">
			<summary>Non-square textures supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.VertexBufferObject">
			<summary>Vertex buffer objects supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.VertexShader_1_1">
			<summary>Vertex shader version 1.1 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.VertexShader_2_0">
			<summary>Vertex shader version 2.0 supported.</summary>
		</member>
		<member name="F:IrrlichtLime.Video.VideoDriverFeature.VertexShader_3_0">
			<summary>Vertex shader version 3.0 supported.</summary>
		</member>
	</members>
</doc>