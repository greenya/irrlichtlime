#pragma once

#include "stdafx.h"
#include "GUIElement.h"

using namespace irr;
using namespace System;

namespace IrrlichtLime {

/// <summary>
/// Information about an event.
/// </summary>
public ref class Event : Lime::NativeValue<SEvent>
{
public:

	/// <summary>
	/// Any kind of GUI event.
	/// </summary>
	value class GUIEvent
	{
	public:

		/// <summary>
		/// Who called the event.
		/// </summary>
		IrrlichtLime::GUI::GUIElement^ Caller;

		/// <summary>
		/// If the event has something to do with another element, it will be held here.
		/// </summary>
		IrrlichtLime::GUI::GUIElement^ Element;

		/// <summary>
		/// Type of GUI event.
		/// </summary>
		IrrlichtLime::GUI::GUIEventType Type;

	internal:

		GUIEvent(const SEvent::SGUIEvent& v)
			: Caller(IrrlichtLime::GUI::GUIElement::Wrap(v.Caller))
			, Element(IrrlichtLime::GUI::GUIElement::Wrap(v.Element))
			, Type((IrrlichtLime::GUI::GUIEventType)v.EventType) {}
	};

	/// <summary>
	/// Any kind of mouse event.
	/// </summary>
	value class MouseEvent
	{
	public:

		/// <summary>
		/// X position of mouse cursor.
		/// </summary>
		int X;

		/// <summary>
		/// Y position of mouse cursor.
		/// </summary>
		int Y;

		/// <summary>
		/// Mouse wheel delta, often 1.0 or -1.0, but can have other values &lt;0.0f or &gt;0.0f.
		/// Only valid if event was <see cref="MouseEventType::Wheel"/>.
		/// </summary>
		float Wheel;

		/// <summary>
		/// True if Shift key was also pressed.
		/// </summary>
		bool Shift;

		/// <summary>
		/// True if CTRL key was also pressed.
		/// </summary>
		bool Control;

		/// <summary>
		/// A bitmap of button states.
		/// You can use Is[button]Pressed() to determine if a button is pressed or not.
		/// Currently only valid if the event was <see cref="MouseEventType::Move"/>.
		/// </summary>
		unsigned int ButtonStates;

		/// <summary>
		/// Type of this mouse event.
		/// </summary>
		MouseEventType Type;

		/// <summary>
		/// Is the left button pressed down?
		/// </summary>
		bool IsLeftPressed() { return 0 != (ButtonStates & EMBSM_LEFT); }

		/// <summary>
		/// Is the right button pressed down?
		/// </summary>
		bool IsRightPressed() { return 0 != (ButtonStates & EMBSM_RIGHT); }

		/// <summary>
		/// Is the middle button pressed down?
		/// </summary>
		bool IsMiddlePressed() { return 0 != (ButtonStates & EMBSM_MIDDLE); }

	internal:

		MouseEvent(const SEvent::SMouseInput& v)
			: X(v.X)
			, Y(v.Y)
			, Wheel(v.Wheel)
			, Shift(v.Shift)
			, Control(v.Control)
			, ButtonStates(v.ButtonStates)
			, Type((MouseEventType)v.Event) {}
	};

	/// <summary>
	/// Any kind of keyboard event.
	/// </summary>
	value class KeyEvent
	{
	public:

		/// <summary>
		/// Character corresponding to the key (0, if not a character, value undefined in key releases).
		/// </summary>
		System::Char Char;

		/// <summary>
		/// Key which has been pressed or released.
		/// </summary>
		KeyCode Key;

		/// <summary>
		/// If not true, then the key was left up.
		/// </summary>
		bool PressedDown;

		/// <summary>
		/// True if Shift key was also pressed.
		/// </summary>
		bool Shift;

		/// <summary>
		/// True if CTRL key was also pressed.
		/// </summary>
		bool Control;

	internal:

		KeyEvent(const SEvent::SKeyInput& v)
			: Char(v.Char)
			, Key((KeyCode)v.Key)
			, PressedDown(v.PressedDown)
			, Shift(v.Shift)
			, Control(v.Control) {}
	};

	/// <summary>
	/// A joystick event.
	/// Unlike other events, joystick events represent the result of polling each connected joystick once per <c>device.Run()</c>.
	/// Joystick events will not be generated by default.
	/// If joystick support is available for the active device and <c>device.ActivateJoysticks()</c> has been called,
	/// an event of this type will be generated once per joystick per <c>device.Run()</c>
	/// regardless of whether the state of the joystick has actually changed.
	/// </summary>
	value class JoystickEvent
	{
	public:

		/// <summary>
		/// Number of buttons.
		/// </summary>
		static property int ButtonCount { int get() { return SEvent::SJoystickEvent::NUMBER_OF_BUTTONS; } }

		/// <summary>
		/// Number of axes.
		/// </summary>
		static property int AxisCount { int get() { return SEvent::SJoystickEvent::NUMBER_OF_AXES; } }

		/// <summary>
		/// A bitmap of button states.
		/// You can use <c>IsButtonPressed()</c> to check the state of each button from 0 to ButtonCount-1.
		/// </summary>
		unsigned int ButtonStates;

		/// <summary>
		/// Array of axes.
		/// Holds AxisCount values; where
		/// index 0 named as X (e.g. analog stick 1 left to right),
		/// index 1 named as Y (e.g. analog stick 1 top to bottom),
		/// index 2 named as Z (e.g. throttle, or analog 2 stick 2 left to right),
		/// index 3 named as R (e.g. rudder, or analog 2 stick 2 top to bottom),
		/// index 4 named as U,
		/// index 5 named as V.
		/// Values are in the range -32768 to 32767, with 0 representing the center position.
		/// You will receive the raw value from the joystick, and so will usually want to implement a dead zone around the center of the range.
		/// Axes not supported by this joystick will always have a value of 0.
		/// On Linux, POV hats are represented as axes, usually the last two active axis.
		/// </summary>
		array<s16>^ Axis;

		/// <summary>
		/// The POV represents the angle of the POV hat in degrees*100, from 0 to 35,900.
		/// A value of 65535 indicates that the POV hat is centered (or not present).
		/// This value is only supported on Windows.
		/// On Linux, the POV hat will be sent as 2 axes instead.
		/// </summary>
		u16 POV;

		/// <summary>
		/// The ID of the joystick which generated this event.
		/// This is an internal Irrlicht index; it does not map directly to any particular hardware joystick.
		/// </summary>
		u8 Joystick;

		/// <summary>
		/// Checks if specific button is pressed.
		/// The button is an index value from 0 to ButtonCount-1.
		/// </summary>
		bool IsButtonPressed(int button)
		{
			LIME_ASSERT(button >= 0 && button < ButtonCount);
			return (ButtonStates & (1 << (unsigned int)button)) ? true : false;
		}

	internal:

		JoystickEvent(const SEvent::SJoystickEvent& v)
			: ButtonStates(v.ButtonStates)
			, Axis(gcnew array<s16>(AxisCount))
			, POV(v.POV)
			, Joystick(v.Joystick)
		{
			for (int i = 0; i < AxisCount; i++)
				Axis[i] = v.Axis[i];
		}
	};

	/// <summary>
	/// Any kind of log event.
	/// </summary>
	value class LogEvent
	{
	public:

		/// <summary>
		/// Text which has been logged.
		/// </summary>
		String^ Text;

		/// <summary>
		/// Log level in which the text has been logged.
		/// </summary>
		LogLevel Level;

	internal:

		LogEvent(const SEvent::SLogEvent& v)
			: Text(gcnew String(v.Text))
			, Level((LogLevel)v.Level) {}
	};

	/// <summary>
	/// Any kind of user event.
	/// </summary>
	value class UserEvent
	{
	public:

		/// <summary>
		/// Some user specified data.
		/// </summary>
		int UserData1;

		/// <summary>
		/// Another user specified data.
		/// </summary>
		int UserData2;

	internal:

		UserEvent(const SEvent::SUserEvent& v)
			: UserData1(v.UserData1)
			, UserData2(v.UserData2) {}
	};

	/// <summary>
	/// Constructs a GUI event.
	/// </summary>
	Event(IrrlichtLime::GUI::GUIEventType type, IrrlichtLime::GUI::GUIElement^ caller, IrrlichtLime::GUI::GUIElement^ element);

	/// <summary>
	/// Constructs a GUI event.
	/// </summary>
	Event(IrrlichtLime::GUI::GUIEventType type, IrrlichtLime::GUI::GUIElement^ caller);

	/// <summary>
	/// Constructs a mouse event.
	/// </summary>
	Event(MouseEventType type, int x, int y, float wheel, unsigned int buttonStates, bool shift, bool control);

	/// <summary>
	/// Constructs a mouse event.
	/// </summary>
	Event(MouseEventType type, int x, int y, float wheel, unsigned int buttonStates);

	/// <summary>
	/// Constructs a mouse event.
	/// </summary>
	Event(MouseEventType type, int x, int y, float wheel);

	/// <summary>
	/// Constructs a mouse event.
	/// </summary>
	Event(MouseEventType type, int x, int y);

	/// <summary>
	/// Constructs a keyboard event.
	/// </summary>
	Event(System::Char ch, KeyCode key, bool pressedDown, bool shift, bool control);

	/// <summary>
	/// Constructs a keyboard event.
	/// </summary>
	Event(System::Char ch, KeyCode key, bool pressedDown);

	/// <summary>
	/// Constructs a joystick event.
	/// </summary>
	Event(u8 joystick, array<s16>^ axis, u16 pov, u32 buttonStates);

	/// <summary>
	/// Constructs a joystick event.
	/// </summary>
	Event(u8 joystick, array<s16>^ axis, u16 pov);

	/// <summary>
	/// Constructs a log event.
	/// </summary>
	Event(String^ logText, LogLevel logLevel);

	/// <summary>
	/// Constructs a log event.
	/// </summary>
	Event(String^ logText);

	/// <summary>
	/// Constructs a user event.
	/// </summary>
	Event(int userData1, int userData2);

	/// <summary>
	/// GUI event.
	/// Valid only when Type is <see cref="EventType::GUI"/>.
	/// </summary>
	property GUIEvent GUI { GUIEvent get(); }

	/// <summary>
	/// Joystick event.
	/// Valid only when Type is <see cref="EventType::Joystick"/>.
	/// </summary>
	property JoystickEvent Joystick { JoystickEvent get(); }

	/// <summary>
	/// Keyboard event.
	/// Valid only when Type is <see cref="EventType::Key"/>.
	/// </summary>
	property KeyEvent Key { KeyEvent get(); }

	/// <summary>
	/// Log event.
	/// Valid only when Type is <see cref="EventType::Log"/>.
	/// </summary>
	property LogEvent Log { LogEvent get(); }

	/// <summary>
	/// Mouse event.
	/// Valid only when Type is <see cref="EventType::Mouse"/>.
	/// </summary>
	property MouseEvent Mouse { MouseEvent get(); }

	/// <summary>
	/// User event.
	/// Valid only when Type is <see cref="EventType::User"/>.
	/// </summary>
	property UserEvent User { UserEvent get(); }

	/// <summary>
	/// Type of this event.
	/// </summary>
	property EventType Type { EventType get(); }

	virtual String^ ToString() override;

internal:

	Event(const SEvent& other);
};

} // end namespace IrrlichtLime
